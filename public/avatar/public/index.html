<!DOCTYPE html>
<html>
<head>
  <title>Avatar Orbix</title>

  <meta charset="utf-8">
  <meta content="width=device-width, height=device-height, minimum-scale=1.0, maximum-scale=1.0, initial-scale=1.0, user-scalable=no, interactive-widget=resizes-content" name="viewport">
  <link rel="icon" type="image/jpg" href="favicon.jpg">
  <link rel="stylesheet" type="text/css" href="css/main.css">

<script nomodule>alert("You browser doesn't seem to support modules. Use a modern browser to run Enterprise.");</script>
<script src="https://d3js.org/d3.v6.min.js"></script>
<script async src="https://cdn.jsdelivr.net/npm/es-module-shims@1.7.1/dist/es-module-shims.js"></script>
<script type="importmap">
{ "imports":
  {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js/+esm",
    "three/examples/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
    "dompurify": "https://cdn.jsdelivr.net/npm/dompurify@3.1.7/+esm",
    "marked": "https://cdn.jsdelivr.net/npm/marked@14.1.3/+esm"
  }
}
</script>
<script src="https://cdn.jsdelivr.net/npm/microsoft-cognitiveservices-speech-sdk@latest/distrib/browser/microsoft.cognitiveservices.speech.sdk.bundle-min.js"></script>

<script type="module">
import { site } from './siteconfig.js'
import { TalkingHead } from "./modules/talkinghead.mjs";
import dompurify from 'dompurify';
import { marked } from 'marked';

// API proxys
const jwtEndpoint = "/app/jwt/get"; // Get JSON Web Token for Single Sign-On
const openaiChatCompletionsProxy = "/openai/v1/chat/completions";
const openaiModerationsProxy = "/openai/v1/moderations";
const openaiAudioTranscriptionsProxy = "/openai/v1/audio/transcriptions";
const geminiProxy = "/gemini/";
const googleTTSProxy = "/gtts/";
const elevenTTSProxy = [
  "wss://" + window.location.host + "/elevenlabs/",
  "/v1/text-to-speech/",
  "/stream-input?model_id=eleven_turbo_v2_5&output_format=pcm_22050"
];
const microsoftTTSProxy = [
  "wss://" + window.location.host + "/mstts/",
  "/cognitiveservices/websocket/v1"
];
const grokChatCompletionsProxy = "/grok/v1/chat/completions"; // Grok-beta
const llamaChatCompletionsProxy = "/llama/v1/chat/completions"; // Local llama.cpp server proxy
const localWhisperCppProxy = "/whisper/"; // Local whisper.cpp server proxy


// Direct API endpoints
const openaiChatCompletionsEndpoint = "https://api.openai.com/v1/chat/completions";
const openaiModerationsEndpoint = "https://api.openai.com/v1/moderations";
const openaiAudioTranscriptionsEndpoint = "https://api.openai.com/v1/audio/transcriptions";
const geminiEndpoint = "https://generativelanguage.googleapis.com/v1beta/models/";
const googleTTSEndpoint = "https://eu-texttospeech.googleapis.com/v1beta1/text:synthesize";
const elevenTTSEndpoint = [
  "wss://api.elevenlabs.io/v1/text-to-speech/",
  "/stream-input?model_id=eleven_turbo_v2_5&output_format=pcm_22050"
];
const microsoftTTSEndpoint = "wss://northeurope.tts.speech.microsoft.com/cognitiveservices/websocket/v1";
const grokChatCompletionsEndpoint = "https://api.x.ai/v1/chat/completions";


// I18n internationalization
const i18n = {

  'fi': {
    'Avatar': 'Hahmo', 'Camera': 'Kamera', 'Audio': 'Ääni', 'Manuscript': 'Käsikirjoitus',
    'Emotion': 'Tunne', 'Neutral': 'Perus', 'Happy': 'Ilo', 'Angry': 'Viha', 'Sad': 'Suru',
    'Fear': 'Pelko', 'Disgust': 'Inho', 'Love': 'Rakkaus', 'Sleep': 'Uni', 'Pose': 'Asento',
    'Action': 'Toiminta', 'Frame': 'Rajaus', 'Full': 'Kokovartalo', 'Upper': 'Yläosa',
    'Head': 'Pää', 'Director': 'Ohjaus', 'Pause': 'Pysäytyskuva', 'Panning': 'Panorointi',
    'Slow-motion': 'Hidastus', 'Ambience': 'Ambienssi', 'Silence': 'Hiljaisuus',
    'Session': 'Sessio', 'Theme': 'Teema', 'Location': 'Paikka', 'Voice': 'Istuva',
    'AI': 'Tekoäly', 'Emoji': 'Emojit', 'Title': 'Otsikko', 'System': 'Ohjeistus',
    'ai-system': 'Järjestelmäviesti.', 'ai-user1': 'Käyttäjän syöte #1',
    'ai-ai1': 'Tekoälyn vaste #1', 'ai-user2': 'Käyttäjän syöte #2',
    'ai-ai2': 'Tekoälyn vaste #2', 'Example1': 'Esim #1', 'Example2': 'Esim #2',
    'Dark': 'Tumma', 'Light': 'Vaalea', 'theme-wide': 'Laajakuva', 'theme-43': '4:3',
    'theme-landscape': 'Vaaka', 'theme-portrait': 'Pysty', 'Empty': 'Tyhjä',
    'Adjust': 'Säätö', 'Speech': 'Puhe', 'Silence': 'Hiljaisuus', 'Framing': 'Rajaus',
    'Mixer': 'Mikseri', 'Space': 'Tila', 'Dry': 'Suora', 'voice-test': 'Äänitesti',
    'Limits': 'Rajat', 'ai-stop': 'Stop', 'ai-stopword': 'Avainsana', 'ai-user': 'Käyttäjä',
    'ai-username': 'Nimi', 'input': 'Kirjoita viesti.', 'Name': 'Nimi', 'Language': 'Kieli',
    'en': 'English', 'fi': 'Finnish', 'words': 'sanaa', 'dialogs': 'sanomaa',
    'Manuscript': 'Käsikirjoitus', 'Exclude': 'Ohita', 'Italics': 'Kursiivi',
    'Code': 'Koodi', 'Light': 'Valo', 'LightAmbient': 'Ambientti',
    'LightDirect': 'Suunnattu', 'LightSpot': 'Spotti', 'theme-full': "Täysi",
    'lt': 'Liettua', 'test-sentence': "Kirjoita tähän testilause.", 'Mid': 'Keskiosa',
    'Gesture': 'Ele', 'PoseMovement': 'Liike', 'Visible': 'Näytä',
    'Helper': 'Apuri', 'Edit': 'Muokkaa', 'Script': 'Skripti'
  },

  'en': {
    'ai-system': 'System message.', 'ai-user1': 'User example #1',
    'ai-ai1': 'AI response #1', 'ai-user2': 'User example #2',
    'ai-ai2': 'AI response #2', 'Example1': 'Example-1', 'Example2': 'Example-2',
    'theme-wide': 'Widescreen', 'theme-43': '4:3', 'theme-landscape': 'Landscape',
    'theme-portrait': 'Portrait', 'voice-test': 'Speak', 'ai-stop': 'Stop',
    'ai-user': 'User', 'input': 'Message.', 'en': 'English', 'fi': 'Finnish',
    'ai-stopword': 'Word', 'ai-username': 'Name', 'LightAmbient': 'Ambient',
    'LightDirect': 'Direct', 'LightSpot': 'Spot', 'theme-full': "Fullscreen",
    'lt': 'Lithuanian', 'test-sentence': "Write your test sentence.",
    'PoseMovement': 'Movement'
  }

}

// i18n
// Default UI language is English

function i18nWord(w,l) {
  l = l || cfg('theme-lang') || 'en';
  return (( i18n[l] && i18n[l][w] ) ? i18n[l][w] : w);
}

function i18nTranslate(l) {
  l = l || cfg('theme-lang') || 'en';

  // Text
  d3.selectAll("[data-i18n-text]").nodes().forEach( n => {
    const e = d3.select(n);
    e.text( i18nWord(e.attr("data-i18n-text"),l ) );
  });

  // Title
  d3.selectAll("[data-i18n-title]").nodes().forEach( n => {
    const e = d3.select(n);
    e.attr( 'title', i18nWord( e.attr("data-i18n-title"),l ) );
  });

  // Placeholder
  d3.selectAll("[data-i18n-placeholder]").nodes().forEach( n => {
    const e = d3.select(n);
    e.attr( 'placeholder', i18nWord( e.attr("data-i18n-placeholder"),l) );
  });

  // Site
  d3.selectAll("[data-i18n-site]").nodes().forEach( n => {
    const e = d3.select(n);
    const label = e.attr("data-i18n-site");
    const [section, ...rest] = label.split('-');
    const item = rest.join('-');
    let text = item;
    if ( site[section] && site[section][item] && site[section][item][l] ) {
      text = site[section][item][l];
    }
    e.text( text );
  });
}

// Markdown configuration
const markedOptions = { gfm: true, breaks: true };

// Open AI configuration
let aiController = null;

// ElevenLabs configuration
const elevenBOS = {
  "text": " ",
  "voice_settings": { "stability": 0.8, "similarity_boost": true },
  "generation_config": {
    "chunk_length_schedule": [500,500,500,500]
  }
};
let elevenSocket = null;
let elevenInputMsgs = null;
let elevenOutputMsg = null;
let elevenOnProcessed = null;

// JSON Web Token (JWT)
let jwtExpires = 0;
let jwt = '';

// Get JSON Web Token
async function jwtGet() {
  const limit = Math.round(Date.now() / 1000) + 60;
  if ( jwtExpires < limit ) {
    try {
      const o = await (await fetch( jwtEndpoint, { cache: "no-store" } )).json();
      if ( o && o.jwt ) {
        const b64Url = o.jwt.split('.')[1];
        const b64 = b64Url.replace(/-/g, '+').replace(/_/g, '/');
        const s = decodeURIComponent( window.atob(b64).split('').map( (c) => {
          return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        }).join(''));
        const p = JSON.parse(s);
        jwtExpires = (p && p.exp) ? p.exp : 0;
        jwt = o.jwt;
      } else {
        jwt = '';
        jwtExpires = 0;
      }
    } catch(e) {
      console.error(e);
      jwt = '';
      jwtExpires = 0;
    }
  }
  return jwt.slice();
}

// Speak using ElevenLabs
async function elevenSpeak(s,node=null) {
  if ( !elevenSocket ) {
    // Temporary reservation of WebSocket connection
    elevenSocket = { readyState: 0 };

    // Temporary stack of message until the connection is established
    elevenInputMsgs = [
      elevenBOS,
      {
        "text": s,
        "try_trigger_generation": false,
        "flush": true
      }
    ];

    // Endpoint/proxy and authentication
    let url;
    const apikey = d3.select("#apikey-eleven").property("value");
    if ( apikey ) {
      url = elevenTTSEndpoint[0];
      url += cfg('voice-eleven-id');
      url += elevenTTSEndpoint[1];
      elevenInputMsgs[0]["xi_api_key"] = apikey;
    } else {
      url = elevenTTSProxy[0];
      url += await jwtGet();
      url += elevenTTSProxy[1];
      url += cfg('voice-eleven-id');
      url += elevenTTSProxy[2];
    }

    // Make the connection
    elevenSocket = new WebSocket(url);

    // Connection opened
    elevenSocket.onopen = function (event) {
      elevenOutputMsg = null;
      while (elevenInputMsgs.length > 0) {
        elevenSocket.send(JSON.stringify(elevenInputMsgs.shift()));
      }
    }

    // New message received
    elevenSocket.onmessage = function (event) {
      const r = JSON.parse(event.data);

      // Speak audio
      if ( (r.isFinal || r.normalizedAlignment) && elevenOutputMsg ) {
        head.speakAudio( elevenOutputMsg, { lipsyncLang: cfg('voice-lipsync-lang') }, node ? addText.bind(null,node) : null );
        if ( elevenOnProcessed ) {
          elevenOnProcessed();
        }
        elevenOutputMsg = null;
      }

      if ( !r.isFinal ) {
        // New part
        if ( r.alignment ) {
          elevenOutputMsg = { audio: [], words: [], wtimes: [], wdurations: [] };

          // Parse chars to words
          let word = '';
          let time = 0;
          let duration = 0;
          for( let i=0; i<r.alignment.chars.length; i++ ) {
            if ( word.length === 0 ) time = r.alignment.charStartTimesMs[i];
            if ( word.length && r.alignment.chars[i] === ' ' ) {
              elevenOutputMsg.words.push( word );
              elevenOutputMsg.wtimes.push(time);
              elevenOutputMsg.wdurations.push(duration);
              word = '';
              duration = 0;
            } else {
              duration += r.alignment.charDurationsMs[i];
              word += r.alignment.chars[i];
            }
          }
          if ( word.length ) {
            elevenOutputMsg.words.push(word);
            elevenOutputMsg.wtimes.push(time);
            elevenOutputMsg.wdurations.push(duration);
          }
        }

        // Add audio content to message
        if ( r.audio &&  elevenOutputMsg ) {
          elevenOutputMsg.audio.push( head.b64ToArrayBuffer( r.audio ) );
        }
      }
    };

    // Error
    elevenSocket.onerror = function (error) {
      if ( elevenOnProcessed ) elevenOnProcessed();
      console.error(`WebSocket Error: ${error}`);
    };

    // Connection closed
    elevenSocket.onclose = function (event) {
      if ( elevenOnProcessed ) elevenOnProcessed();
      if ( event.wasClean) {
        // console.info(`Connection closed cleanly, code=${event.code}, reason=${event.reason}`);
      } else {
        console.warn('Connection died');
      }
      elevenSocket = null;
    };
  } else {
    let msg = {
      "text": s
    };
    if ( s.length ) {
      msg["try_trigger_generation"] = false;
      msg["flush"] = true;
    }
    if (elevenSocket.readyState === 1) { // OPEN
      elevenSocket.send(JSON.stringify(msg))
    } else if ( elevenSocket.readyState === 0 ) { // CONNECTING
      elevenInputMsgs.push(msg);
    }
  }
}

// Speak using Microsoft
let microsoftSynthesizer = null;
const microsoftQueue= [];

async function microsoftSpeak(s, node=null, onprocessed=null) {

  if ( s === null ) {
    microsoftQueue.push( null );
  } else {

    // Voice config
    const id = cfg("voice-microsoft-id");
    const e = d3.select("[data-voice-microsoft-id='" + id + "']");
    const lang = e.attr("data-voice-microsoft-lang");

    // SSML
    const ssml = "<speak version='1.0' " +
      "xmlns:mstts='http://www.w3.org/2001/mstts' " +
      "xml:lang='" + lang + "'>" +
      "<voice name='" + id + "'>" +
      "<mstts:viseme type='redlips_front'/>" +
      s.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;') +
      "</voice>" +
      "</speak>";

    microsoftQueue.push( {
      ssml: ssml,
      node: node,
      onprocessed: onprocessed,
      speak: {
        audio: [], words: [], wtimes: [], wdurations: [],
        visemes: [], vtimes: [], vdurations: [], markers: [], mtimes: []
      }
     } );
  }

  // If this was the first item, start the process
  if ( microsoftQueue.length === 1 ) {
    microsoftProcessQueue();
  }
}

async function microsoftProcessQueue() {

  if ( microsoftQueue.length ) {

    const job = microsoftQueue[0];

    if ( job === null ) {
      microsoftQueue.shift();
      if ( microsoftQueue.length === 0 &&  microsoftSynthesizer ) {
        microsoftSynthesizer.close();
        microsoftSynthesizer = null;
      }
    } else {

      // If we do not have a speech synthesizer, create a new
      if ( !microsoftSynthesizer ) {

        // Create a new speech synthesizer
        let endpoint;
        let config;
        const apikey = d3.select("#apikey-microsoft").property("value");
        if ( apikey ) {
          endpoint = microsoftTTSEndpoint;
          config = window.SpeechSDK.SpeechConfig.fromEndpoint(endpoint, apikey);
        } else {
          endpoint = microsoftTTSProxy[0] + await jwtGet() + microsoftTTSProxy[1];
          config = window.SpeechSDK.SpeechConfig.fromEndpoint(endpoint);
        }
        config.setProperty("SpeechServiceConnection_Endpoint",endpoint);
        config.speechSynthesisOutputFormat = window.SpeechSDK.SpeechSynthesisOutputFormat.Raw22050Hz16BitMonoPcm;
        config.setProperty(window.SpeechSDK.PropertyId.SpeechServiceResponse_RequestSentenceBoundary, "true");
        microsoftSynthesizer = new window.SpeechSDK.SpeechSynthesizer(config,null);

        // Viseme conversion from Microsoft to Oculus
        // TODO: Check this conversion again!
        const visemeMap = [
          "sil", 'aa', 'aa', 'O', 'E', // 0 - 4
          'E', 'I', 'U', 'O', 'aa', // 5 - 9
          'O', 'I', 'kk', 'RR', 'nn', // 10 - 14
          'SS', 'SS', 'TH', 'FF', 'DD', // 15 - 19
          'kk', 'PP' // 20 - 21
        ];

        // Process visemes
        microsoftSynthesizer.visemeReceived = function(s, e) {
          if ( microsoftQueue[0] && microsoftQueue[0].speak ) {
            const o = microsoftQueue[0].speak;
            const viseme = visemeMap[e.visemeId];
            const time = e.audioOffset / 10000;

            // Calculate the duration of the previous viseme
            if ( o.vdurations.length ) {

              if ( o.visemes[ o.visemes.length-1 ] === 0 ) {
                o.visemes.pop();
                o.vtimes.pop();
                o.vdurations.pop();
              } else {
                // Remove silence
                o.vdurations[ o.vdurations.length-1 ] = time - o.vtimes[ o.vdurations.length-1 ];
              }
            }



            // Add this viseme
            o.visemes.push( viseme );
            o.vtimes.push( time );
            o.vdurations.push( 75 ); // Duration will be fixed when the next viseme is received
          }
        };

        // Process word boundaries and punctuations
        microsoftSynthesizer.wordBoundary = function (s, e) {
          if ( microsoftQueue[0] && microsoftQueue[0].speak ) {
            const o = microsoftQueue[0].speak;
            const word = e.text;
            const time = e.audioOffset / 10000;
            const duration = e.duration / 10000;

            if ( e.boundaryType === "PunctuationBoundary" && o.words.length ) {
              o.words[ o.words.length-1 ] += word;
            } else if ( e.boundaryType === "WordBoundary" || e.boundaryType === "PunctuationBoundary" ) {
              o.words.push( word );
              o.wtimes.push( time );
              o.wdurations.push( duration );
            } else if ( e.boundaryType === "SentenceBoundary" ) {
              if ( time > 500 ) {
                o.markers.push( () => { head.lookAtCamera(500); });
                o.mtimes.push( time - 500 );
              }
            }
          }
        };

      }

      // Speak the SSML
      microsoftSynthesizer.speakSsmlAsync(job.ssml,
        function (result) {
          if ( microsoftQueue[0] && microsoftQueue[0].speak ) {
            if (result.reason === window.SpeechSDK.ResultReason.SynthesizingAudioCompleted) {
              const job = microsoftQueue[0];
              job.speak.audio.push( result.audioData );
              head.speakAudio(job.speak, {}, job.node ? addText.bind(null,job.node) : null );
              if ( job.onprocessed ) job.onprocessed();
            }
            microsoftQueue.shift();
            microsoftProcessQueue();
          }
        }, function (err) {
          if ( job.onprocessed ) job.onprocessed();
          console.log(err);
          microsoftQueue.shift();
          microsoftProcessQueue();
        }
      );

    }
  }
}

// Whisper MP3
let whisperAudio = null;
let whisperLipsyncLang = 'en';

async function whisperLoadMP3(file) {

  if ( cfg("whisper-type") === "openai" ) {
    try {
      d3.select("#playmp3").classed("disabled", true);

      const form = new FormData();
      form.append("file", file);
      form.append("model", "whisper-1");
      form.append("response_format", "verbose_json" );
      form.append("prompt","[The following is a full verbatim transcription without additional details, comments or emojis:]");
      form.append("timestamp_granularities[]", "word" );
      form.append("timestamp_granularities[]", "segment" );

      // Endpoint/proxy and authentication
      let url;
      let headers = {};
      const apikey = d3.select("#apikey-openai").property("value");
      if ( apikey ) {
        url = openaiAudioTranscriptionsEndpoint;
        headers["Authorization"] = "Bearer " + apikey;
      } else {
        url = openaiAudioTranscriptionsProxy;
        headers["Authorization"] = "Bearer " + await jwtGet()
      }

      const response = await fetch( url , {
        method: "POST",
        body: form,
        headers: headers
      });
      if ( response.ok ) {
        const json = await response.json();
        d3.select("#jsonmp3").property("value", JSON.stringify(json) );

        // Fetch audio
        if ( json.words && json.words.length ) {
          var reader = new FileReader();
          reader.readAsArrayBuffer(file);
          reader.onload = async readerEvent => {
            let arraybuffer = readerEvent.target.result;
            let audiobuffer = await head.audioCtx.decodeAudioData(arraybuffer);

            // Set lip-sync language
            whisperLipsyncLang = json.language.substring(0,2);

            // Add words to the audio object
            whisperAudio = {
              audio: audiobuffer,
              words: [],
              wtimes: [],
              wdurations: [],
              markers: [],
              mtimes: []
            };
            json.words.forEach( x => {
              // Word
              whisperAudio.words.push( x.word );

              // Starting time
              let t = 1000 * x.start;
              if ( t > 150 ) t -= 150;
              whisperAudio.wtimes.push( t );

              // Duration
              let d = 1000 * (x.end - x.start);
              if ( d > 20 ) d -= 20;
              whisperAudio.wdurations.push( d  );
            });

            // Add timed callback markers to the audio object
            const startSegment = async () => {
              // Look at the camera
              head.lookAtCamera(500);
              head.speakWithHands();
            };
            json.segments.forEach( x => {
              if ( x.start > 2 && x.text.length > 10 ) {
                whisperAudio.markers.push( startSegment );
                whisperAudio.mtimes.push( 1000 * x.start - 1000 );
              }
            });

            d3.select("#playmp3").classed("disabled", false);
          }
        }

      } else {
        d3.select("#jsonmp3").property("value", 'Error: ' + response.status + ' ' + response.statusText );
        console.log(response);
      }

    } catch (error) {
      console.log(error);
    }
  } else if ( cfg("whisper-type") === "local" ) {
    try {
      d3.select("#playmp3").classed("disabled", true);

      const form = new FormData();
      form.append("file", file);
      form.append("temperature","0.0");
      form.append("temperature_inc", "0.2");
      form.append("response_format", "verbose_json");
      const response = await fetch( localWhisperCppProxy + 'inference' , {
        method: "POST",
        body: form,
        headers: {
          "Authorization": "Bearer " + await jwtGet()
        }
      });
      if ( response.ok ) {
        const json = await response.json();
        d3.select("#jsonmp3").property("value", JSON.stringify(json) );

        // Fetch audio
        if ( json.segments && json.segments.length ) {
          var reader = new FileReader();
          reader.readAsArrayBuffer(file);
          reader.onload = async readerEvent => {
            let arraybuffer = readerEvent.target.result;
            let audiobuffer = await head.audioCtx.decodeAudioData(arraybuffer);

            // Set lip-sync language
            whisperLipsyncLang = json.language.substring(0,2);

            // Add words to the audio object
            whisperAudio = {
              audio: audiobuffer,
              words: [],
              wtimes: [],
              wdurations: [],
              markers: [],
              mtimes: []
            };

            // Add timed callback markers to the audio object
            const startSegment = async () => {
              // Look at the camera
              head.lookAtCamera(500);
              head.speakWithHands();
            };

            json.segments.forEach( (x,i) => {
              if ( x.words && x.words.length ) {

                // Look at camera
                if ( x.start > 2 && x.text.length > 10 ) {
                  whisperAudio.markers.push( startSegment );
                  whisperAudio.mtimes.push( 1000 * x.start - 1000 );
                }

                // Word-level timestamps
                x.words.forEach( y => {

                  // Word
                  whisperAudio.words.push( y.word );

                  // Starting time
                  let t = 1000 * y.start;
                  if ( t > 150 ) t -= 150;
                  whisperAudio.wtimes.push( t );

                  // Duration
                  let d = 1000 * (y.end - y.start);
                  if ( d <= 50 ) d = 50;
                  if ( d > 20 ) d -= 20;
                  whisperAudio.wdurations.push( d  );

                });
              }
            });

            d3.select("#playmp3").classed("disabled", false);
          }
        }

      } else {
        d3.select("#jsonmp3").property("value", 'Error: ' + response.status + ' ' + response.statusText );
        console.log(response);
      }

    } catch (error) {
      console.log(error);
    }
  }

}


// RECORDING
let recordingMediaRecorder = null;
let recordingAnalyzer = null;
let recordingIgnoreData = false;
let recordingChunks = [];
const recordingMediaTypes = [
  { type: "audio/webm", ext: "webm" },
  { type: "video/mp4", ext: "mp4" }
];
let recordingMediaType = {};
for( let i=0; i<recordingMediaTypes.length; i++ ) {
  if ( MediaRecorder.isTypeSupported(recordingMediaTypes[i].type) ) {
    recordingMediaType = recordingMediaTypes[i];
    break;
  }
}
const recordingBeep = "data:audio/wav;base64,//uQRAAAAWMSLwUIYAAsYkXgoQwAEaYLWfkWgAI0wWs/ItAAAGDgYtAgAyN+QWaAAihwMWm4G8QQRDiMcCBcH3Cc+CDv/7xA4Tvh9Rz/y8QADBwMWgQAZG/ILNAARQ4GLTcDeIIIhxGOBAuD7hOfBB3/94gcJ3w+o5/5eIAIAAAVwWgQAVQ2ORaIQwEMAJiDg95G4nQL7mQVWI6GwRcfsZAcsKkJvxgxEjzFUgfHoSQ9Qq7KNwqHwuB13MA4a1q/DmBrHgPcmjiGoh//EwC5nGPEmS4RcfkVKOhJf+WOgoxJclFz3kgn//dBA+ya1GhurNn8zb//9NNutNuhz31f////9vt///z+IdAEAAAK4LQIAKobHItEIYCGAExBwe8jcToF9zIKrEdDYIuP2MgOWFSE34wYiR5iqQPj0JIeoVdlG4VD4XA67mAcNa1fhzA1jwHuTRxDUQ//iYBczjHiTJcIuPyKlHQkv/LHQUYkuSi57yQT//uggfZNajQ3Vmz+ Zt//+mm3Wm3Q576v////+32///5/EOgAAADVghQAAAAA//uQZAUAB1WI0PZugAAAAAoQwAAAEk3nRd2qAAAAACiDgAAAAAAABCqEEQRLCgwpBGMlJkIz8jKhGvj4k6jzRnqasNKIeoh5gI7BJaC1A1AoNBjJgbyApVS4IDlZgDU5WUAxEKDNmmALHzZp0Fkz1FMTmGFl1FMEyodIavcCAUHDWrKAIA4aa2oCgILEBupZgHvAhEBcZ6joQBxS76AgccrFlczBvKLC0QI2cBoCFvfTDAo7eoOQInqDPBtvrDEZBNYN5xwNwxQRfw8ZQ5wQVLvO8OYU+mHvFLlDh05Mdg7BT6YrRPpCBznMB2r//xKJjyyOh+cImr2/4doscwD6neZjuZR4AgAABYAAAABy1xcdQtxYBYYZdifkUDgzzXaXn98Z0oi9ILU5mBjFANmRwlVJ3/6jYDAmxaiDG3/6xjQQCCKkRb/6kg/wW+kSJ5//rLobkLSiKmqP/0ikJuDaSaSf/6JiLYLEYnW/+kXg1WRVJL/9EmQ1YZIsv/6Qzwy5qk7/+tEU0nkls3/zIUMPKNX/6yZLf+kFgAfgGyLFAUwY//uQZAUABcd5UiNPVXAAAApAAAAAE0VZQKw9ISAAACgAAAAAVQIygIElVrFkBS+Jhi+EAuu+lKAkYUEIsmEAEoMeDmCETMvfSHTGkF5RWH7kz/ESHWPAq/kcCRhqBtMdokPdM7vil7RG98A2sc7zO6ZvTdM7pmOUAZTnJW+NXxqmd41dqJ6mLTXxrPpnV8avaIf5SvL7pndPvPpndJR9Kuu8fePvuiuhorgWjp7Mf/PRjxcFCPDkW31srioCExivv9lcwKEaHsf/7ow2Fl1T/9RkXgEhYElAoCLFtMArxwivDJJ+bR1HTKJdlEoTELCIqgEwVGSQ+hIm0NbK8WXcTEI0UPoa2NbG4y2K00JEWbZavJXkYaqo9CRHS55FcZTjKEk3NKoCYUnSQ 0rWxrZbFKbKIhOKPZe1cJKzZSaQrIyULHDZmV5K4xySsDRKWOruanGtjLJXFEmwaIbDLX0hIPBUQPVFVkQkDoUNfSoDgQGKPekoxeGzA4DUvnn4bxzcZrtJyipKfPNy5w+9lnXwgqsiyHNeSVpemw4bWb9psYeq//uQZBoABQt4yMVxYAIAAAkQoAAAHvYpL5m6AAgAACXDAAAAD59jblTirQe9upFsmZbpMudy7Lz1X1DYsxOOSWpfPqNX2WqktK0DMvuGwlbNj44TleLPQ+Gsfb+GOWOKJoIrWb3cIMeeON6lz2umTqMXV8Mj30yWPpjoSa9ujK8SyeJP5y5mOW1D6hvLepeveEAEDo0mgCRClOEgANv3B9a6fikgUSu/DmAMATrGx7nng5p5iimPNZsfQLYB2sDLIkzRKZOHGAaUyDcpFBSLG9MCQALgAIgQs2YunOszLSAyQYPVC2YdGGeHD2dTdJk1pAHGAWDjnkcLKFymS3RQZTInzySoBwMG0QueC3gMsCEYxUqlrcxK6k1LQQcsmyYeQPdC2YfuGPASCBkcVMQQqpVJshui1tkXQJQV0OXGAZMXSOEEBRirXbVRQW7ugq7IM7rPWSZyDlM3IuNEkxzCOJ0ny2ThNkyRai1b6ev//3dzNGzNb//4uAvHT5sURcZCFcuKLhOFs8mLAAEAt4UWAAIABAAAAAB4qbHo0tIjVkUU//uQZAwABfSFz3ZqQAAAAAngwAAAE1HjMp2qAAAAACZDgAAAD5UkTE1UgZEUExqYynN1qZvqIOREEFmBcJQkwdxiFtw0qEOkGYfRDifBui9MQg4QAHAqWtAWHoCxu1Yf4VfWLPIM2mHDFsbQEVGwyqQoQcwnfHeIkNt9YnkiaS1oizycqJrx4KOQjahZxWbcZgztj2c49nKmkId44S71j0c8eV9yDK6uPRzx5X18eDvjvQ6yKo9ZSS6l//8elePK/Lf//IInrOF/FvDoADYAGBMGb7 FtErm5MXMlmPAJQVgWta7Zx2go+8xJ0UiCb8LHHdftWyLJE0QIAIsI+UbXu67dZMjmgDGCGl1H+vpF4NSDckSIkk7Vd+sxEhBQMRU8j/12UIRhzSaUdQ+rQU5kGeFxm+hb1oh6pWWmv3uvmReDl0UnvtapVaIzo1jZbf/pD6ElLqSX+rUmOQNpJFa/r+sa4e/pBlAABoAAAAA3CUgShLdGIxsY7AUABPRrgCABdDuQ5GC7DqPQCgbbJUAoRSUj+NIEig0YfyWUho1VBBBA//uQZB4ABZx5zfMakeAAAAmwAAAAF5F3P0w9GtAAACfAAAAAwLhMDmAYWMgVEG1U0FIGCBgXBXAtfMH10000EEEEEECUBYln03TTTdNBDZopopYvrTTdNa325mImNg3TTPV9q3pmY0xoO6bv3r00y+IDGid/9aaaZTGMuj9mpu9Mpio1dXrr5HERTZSmqU36A3CumzN/9Robv/Xx4v9ijkSRSNLQhAWumap82WRSBUqXStV/YcS+XVLnSS+WLDroqArFkMEsAS+eWmrUzrO0oEmE40RlMZ5+ODIkAyKAGUwZ3mVKmcamcJnMW26MRPgUw6j+LkhyHGVGYjSUUKNpuJUQoOIAyDvEyG8S5yfK6dhZc0Tx1KI/gviKL6qvvFs1+bWtaz58uUNnryq6kt5RzOCkPWlVqVX2a/EEBUdU1KrXLf40GoiiFXK///qpoiDXrOgqDR38JB0bw7SoL+ZB9o1RCkQjQ2CBYZKd/+VJxZRRZlqSkKiws0WFxUyCwsKiMy7hUVFhIaCrNQsKkTIsLivwKKigsj8XYlwt/WKi2N4d//uQRCSAAjURNIHpMZBGYiaQPSYyAAABLAAAAAAAACWAAAAApUF/Mg+0aohSIRobBAsMlO//Kk4soosy1JSFRYWaLC4qZBYWFRGZdwqKiwkNBVmoWFSJkWFxX4FFRQWR+LsS4W/rFRb//////////////////////////// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VEFHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU291bmRib3kuZGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAwNGh0dHA6Ly93d3cuc291bmRib3kuZGUAAAAAAAAAACU=";
const recordingPlaySound = (function beep() {
  const snd = new Audio(recordingBeep);
  return function() { snd.play(); }
})();


async function recordingRecord() {
  if ( !recordingMediaRecorder ) {
    try {
      if ( !navigator.mediaDevices ) throw new Error("No navigator.mediaDevices available for recording.");
      let stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
      recordingMediaRecorder = new MediaRecorder(stream, { mimeType: recordingMediaType.type });
      recordingMediaRecorder.ondataavailable = async (event) => {

        // If marked ignore, do not transcribe
        if ( recordingIgnoreData ) {
          recordingIgnoreData = false;
          return;
        } else {
          console.log('Recorded data:',event);
          recordingIgnoreData = false;
        }

        if ( event.data.size > 0 ) {

          // Make a transcription
          const file = new File([event.data], 'file.'+recordingMediaType.ext, { type: recordingMediaType.type });
          const form = new FormData();
          form.append("file", file);

          if ( cfg("whisper-type") === "openai" ) {

            form.append("model", "whisper-1");
            const lang = cfg('theme-lang') || 'en';
            form.append("language", lang);
            const response = await fetch( openaiAudioTranscriptionsProxy , {
              method: "POST",
              body: form,
              headers: {
                "Authorization": "Bearer " + await jwtGet()
              }
            });

            // Append text to input
            if ( response.ok ) {
              let json;
              try {
                json = await response.json();
              } catch(error) {
                console.error("Invalid response from OpenAI");
              }
              if ( json && json.text ) {
                const e = d3.select("#input");
                let text = e.property("value");
                if ( text ) {
                  e.property("value", text + ' ' + json.text );
                } else {
                  e.property("value", json.text );
                }
              }
            }
          } else if ( cfg("whisper-type") === "local" ) {

            form.append("temperature","0.0");
            form.append("temperature_inc", "0.2");
            form.append("response_format", "json");

            const response = await fetch( localWhisperCppProxy + 'inference' , {
              method: "POST",
              body: form,
              headers: {
                "Authorization": "Bearer " + await jwtGet()
              }
            });

            // Append text to input
            if ( response.ok ) {
              let json;
              try {
                json = await response.json();
              } catch(error) {
                console.error("Invalid response from local Whisper");
              }
              if ( json && json.text ) {
                const e = d3.select("#input");
                let text = e.property("value");

                let s = json.text
                  .replace(/\[[^\]]+\]/g, '')
                  .replaceAll(/[^\p{L}\p{N},\.\p{Quotation_Mark}!€\$\+\p{Dash_Punctuation}%&\?\(\)\* ]/ug,"")
                  .replaceAll("  "," ")
                  .trim();

                if ( text ) {
                  e.property("value", text + ' ' + s );
                } else {
                  e.property("value", s );
                }
              }
            }

          }

        }
      };

      // Connect to TalkingHead
      recordingAnalyzer = head.audioCtx.createAnalyser();
      const recordingSource = head.audioCtx.createMediaStreamSource(stream);
      recordingSource.connect(recordingAnalyzer);

    } catch (error) {
      d3.select("#record").classed("selected",false);
      console.error('Error accessing microphone:', error);
      return;
    }
  }

  try {
    if ( recordingAnalyzer ) {
      head.startListening( recordingAnalyzer,{},(status) => {

        switch(status) {
        case 'start':
          head.lookAtCamera(2000);
          break;
        case 'stop':
          if ( recordingMediaRecorder ) {
            // recordingMediaRecorder.requestData();
            recordingMediaRecorder.stop();
            recordingMediaRecorder.start();
          }
          break;
        case 'maxsilence':
          if ( recordingMediaRecorder ) {
            recordingIgnoreData = true;
            // recordingMediaRecorder.requestData();
            recordingMediaRecorder.stop();
            recordingMediaRecorder.start();
          }
          break;
        case 'maxactive':
          if ( recordingMediaRecorder ) {
            recordingIgnoreData = true;
            // recordingMediaRecorder.requestData();
            recordingMediaRecorder.stop();
            recordingMediaRecorder.start();
          }
          break;
        }
      });
    }

    recordingIgnoreData = false;
    if ( recordingMediaRecorder ) {
      recordingMediaRecorder.start();
    }

  } catch(error) {
    d3.select("#record").classed("selected",false);
    console.error('Recorder error:', error);
  }
}


// Number of words on a string.
function nWords(str) {
  return str ? str.trim().split(/\s+/).length : 0;
}

// Default settings
let CFG = {
  session: 0,
  sessions : [
    {
      name: "Nimetön",
      theme: { lang: 'en', brightness:"dark", ratio:"wide", layout:"port" },
      view: { image: 'NONE' },
      avatar: {},
      camera: { frame: 'full' },
      ai: {},
      voice: { background: "NONE", type: "google", google:{ id: "en-GB-Standard-A"}, lipsync:{ lang: 'en' } }
    },
    {
      name: "Nimetön 2",

      theme: { lang: 'en', brightness: "dark", ratio: "wide", layout: "land" },
      view: { image: 'NONE' },
      avatar: {},
      camera: { frame: 'upper' },
      ai: {},
      voice: { background: "NONE", type: "google", google:{ id: "en-GB-Standard-A"}, lipsync:{ lang: 'en' } }
    },
  ]
};

// Dynamically created icons
const svgSelect = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M10.5858 13.4142L7.75735 10.5858L6.34314 12L10.5858 16.2427L17.6568 9.1716L16.2426 7.75739L10.5858 13.4142Z" fill="currentColor" /></svg>';
const svgSpeak = '<svg viewBox="-2 -2 28 28" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 18.939C14.2091 18.939 16 17.1482 16 14.939C16 12.7299 14.2091 10.939 12 10.939C9.79086 10.939 8 12.7299 8 14.939C8 17.1482 9.79086 18.939 12 18.939ZM12 16.939C13.1046 16.939 14 16.0436 14 14.939C14 13.8345 13.1046 12.939 12 12.939C10.8954 12.939 10 13.8345 10 14.939C10 16.0436 10.8954 16.939 12 16.939Z" fill="currentColor" /><path d="M12 9.04401C13.1046 9.04401 14 8.14858 14 7.04401C14 5.93944 13.1046 5.04401 12 5.04401C10.8954 5.04401 10 5.93944 10 7.04401C10 8.14858 10.8954 9.04401 12 9.04401Z" fill="currentColor" /><path fill-rule="evenodd" clip-rule="evenodd" d="M7 1C5.34315 1 4 2.34315 4 4V20C4 21.6569 5.34315 23 7 23H17C18.6569 23 20 21.6569 20 20V4C20 2.34315 18.6569 1 17 1H7ZM17 3H7C6.44772 3 6 3.44772 6 4V20C6 20.5523 6.44772 21 7 21H17C17.5523 21 18 20.5523 18 20V4C18 3.44772 17.5523 3 17 3Z" fill="currentColor" /></svg>'
const svgStop = '<svg viewBox="-2 -2 28 28" xmlns="http://www.w3.org/2000/svg"><path d="M6.2253 4.81108C5.83477 4.42056 5.20161 4.42056 4.81108 4.81108C4.42056 5.20161 4.42056 5.83477 4.81108 6.2253L10.5858 12L4.81114 17.7747C4.42062 18.1652 4.42062 18.7984 4.81114 19.1889C5.20167 19.5794 5.83483 19.5794 6.22535 19.1889L12 13.4142L17.7747 19.1889C18.1652 19.5794 18.7984 19.5794 19.1889 19.1889C19.5794 18.7984 19.5794 18.1652 19.1889 17.7747L13.4142 12L19.189 6.2253C19.5795 5.83477 19.5795 5.20161 19.189 4.81108C18.7985 4.42056 18.1653 4.42056 17.7748 4.81108L12 10.5858L6.2253 4.81108Z" fill="currentColor" /></svg>';
const svgRepost = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13.1459 11.0499L12.9716 9.05752L15.3462 8.84977C14.4471 7.98322 13.2242 7.4503 11.8769 7.4503C9.11547 7.4503 6.87689 9.68888 6.87689 12.4503C6.87689 15.2117 9.11547 17.4503 11.8769 17.4503C13.6977 17.4503 15.2911 16.4771 16.1654 15.0224L18.1682 15.5231C17.0301 17.8487 14.6405 19.4503 11.8769 19.4503C8.0109 19.4503 4.87689 16.3163 4.87689 12.4503C4.87689 8.58431 8.0109 5.4503 11.8769 5.4503C13.8233 5.4503 15.5842 6.24474 16.853 7.52706L16.6078 4.72412L18.6002 4.5498L19.1231 10.527L13.1459 11.0499Z" fill="currentColor" /></svg>';

// Get/set config value for the current session
function cfg(key,value) {
  if ( key === undefined ) return CFG.sessions[CFG.session];
  let parts = key.split('-').map( x => isNaN(x) ? x : parseInt(x) );
  if ( value === undefined ) {
    return parts.reduce( (o,p) => o ? o[p] : undefined, CFG.sessions[CFG.session] );
  } else {
    parts.reduce( (o,p,i) => {
      const def = (typeof parts[i+1] === 'number') ? [] : {};
      return (o[p] = (parts.length-1) === i ? value : (o[p] || def));
    }, CFG.sessions[CFG.session] );
  }
}

// Load settings
try {
  let json = localStorage.getItem('talkinghead');
  CFG = (json ? JSON.parse(json) : CFG);
} catch(error) {
  alert("Invalid JSON settings");
  console.error(error);
}

window.cfg = cfg;

// Save config to localStorage and show active session config
let loadingConfig = false;
function saveConfig() {
  if ( !loadingConfig ) {
    let json = JSON.stringify(CFG);
    localStorage.setItem("talkinghead", json);
    json = JSON.stringify( cfg() );
    d3.select("#json").property("value", json );
  }
}

// Load config for the given session
function loadConfig(session = null) {
  try {
    loadingConfig = true;
    let json = localStorage.getItem('talkinghead');
    const config = (json ? JSON.parse(json) : CFG);
    if ( config && config.hasOwnProperty("session") && config.hasOwnProperty("sessions") && config.sessions.length ) {
      CFG = config;
      if ( session !== null && session >= 0 && session < CFG.sessions.length ) {
        CFG.session = session;
        json = JSON.stringify(CFG);
        localStorage.setItem("talkinghead", json);
      }

      // Populate sessions
      d3.selectAll(".session").nodes().forEach( n => {
        const e = d3.select(n);
        const id = parseInt( e.property("id").split("-")[1] );
        if ( id >= 0 && id < CFG.sessions.length ) {
          e.classed("selected", (id === CFG.session) );
        } else {
          e.remove();
        }
      });
      for( let i=0; i<CFG.sessions.length; i++ ) {
        const e = d3.select("#session-"+i);
        if ( e.empty() ) {
          d3.select("#sessions").append("div")
            .property("id","session-"+i)
            .classed("session", true)
            .classed("selected", (i === CFG.session) );
        }
      }

      // Populate directory
      d3.selectAll(".entry").nodes().forEach( n => {
        const e = d3.select(n);
        const id = parseInt( e.property("id").split("-")[1] );
        if ( id >= 0 && id < CFG.sessions.length ) {
          let name = CFG.sessions[id].name;
          if ( !name || name.length === 0 ) {
            name = "Nimetön";
            CFG.sessions[id].name = name;
          }
          e.select("div")
            .classed("selected", (id === CFG.session) )
            .text( name );
        } else {
          e.remove();
        }
      });
      for( let i=0; i<CFG.sessions.length; i++ ) {
        const e = d3.select("#entry-"+i);
        if ( e.empty() ) {
          let n = d3.select("#directory").node().lastElementChild;
          let name = CFG.sessions[i].name;
          if ( !name || name.length === 0 ) {
            name = "Nimetön";
            CFG.sessions[i].name = name;
          }
          let clone = d3.select(n).clone(true);
          clone.property("id","entry-"+i);
          clone.select("[data-session]")
            .attr("data-session", i)
            .classed("selected", (i === CFG.session) )
            .text(name)
            .on('click.command', entrySelect);
          clone.selectAll("[data-entry-move]")
            .on('click.command', entryMove );
        }
      }

      // Populate settings page in specific order
      [
        "[data-item='view-url']", "[data-item='avatar-url']",
        "[data-item='avatar-body']","[data-item]"
      ].forEach( x => {
        d3.selectAll(x).nodes().forEach( (n) => {
          const e = d3.select(n);
          const item = e.attr("data-item");
          const type = e.attr("data-type");
          const range = e.attr("data-range");
          let value = cfg( item );
          if ( value !== undefined ) {
            if ( type === 'boolean' ) {
              e.classed( "selected", value )
            } else if ( type === 'option' ) {
              if ( value === e.attr("data-"+item) ) {
                e.dispatch("click");
              }
            } else if ( type === 'value' ) {
              e.property("value",value).dispatch("change");
            }
          } else {
            if ( type === 'boolean' ) {
              cfg( item, e.classed( "selected" ) );
            } else if ( type === 'option' ) {
              if ( e.classed("selected") ) {
                cfg( item, e.attr("data-"+item) );
                e.dispatch("click");
              }
            } else {
              if ( range !== null ) {
                cfg( item, parseFloat( e.property("value") ) );
              } else {
                cfg( item, e.property("value") );
              }
              e.dispatch("change");
            }
          }
        });
      });

      // Populate other parts of UI,
      d3.select("#name").text( cfg("name") );
      if ( d3.select("[data-item='view-image'].selected").empty() ) {
        d3.select("[data-item='view-image']").classed("selected",true).dispatch('click');
      }
      if ( d3.select("[data-item='avatar-name'].selected").empty() ) {
        d3.select("[data-item='avatar-name']").classed("selected",true).dispatch('click');
      }
      scriptInit();
      json = JSON.stringify( cfg() );
      d3.select("#json").property("value",json);
    }
  } catch(error) {
    alert("Invalid JSON settings");
    console.error(error);
  } finally {
    loadingConfig = false;
    saveConfig();
  }
}

// Process string s for parts to exclude from speech/lip-sync
// For continued stream of strings the previous state o can be given
function excludesProcess(s,o=null) {

  // If no previous rules and states, build rules based on user settings
  if ( !o || !o.rules || !Array.isArray(o.rules) ) {
    o = { rules: [] };
    if ( cfg('voice-exclude-italics') ) {
      o.rules.push( { separator: '*', open: false });
    }
    if ( cfg('voice-exclude-code') ) {
      o.rules.push( { separator: '```', open: false });
    }
  }

  // Excludes is an array of [start,end] index pairs
  o.excludes = [];

  // If there are rules, process them
  o.rules.forEach( x => {
    const parts = s.split(x.separator);
    let i = 0;
    parts.forEach( (y,j) => {
      const isLast = (j === (parts.length - 1));
      if ( x.open ) {
        const start = i - (j===0 ? 0 : x.separator.length);
        const end = i + y.length - 1 + (isLast ? x.separator.length : 0);
        o.excludes.push( [start, end] ); // Exclude
      }
      if ( !isLast ) {
        i += y.length + x.separator.length;
        x.open = !x.open;
      }
    });
  });

  return o;
}

function motion( action, pose, gesture, mood ) {
  try {
    head.setMood(mood || 'neutral');
  } catch(err) {}
  if ( gesture && site.gestures[gesture] ) {
    head.playGesture(site.gestures[gesture].name);
  }
  if ( action && site.animations[action] ) {
    head.playAnimation( site.animations[action].url, progressUpdate, site.animations[action].dur || 20 );
  } else if ( pose && site.poses[pose] ) {
    head.playPose( site.poses[pose].url, progressUpdate, site.poses[pose].dur || 60 );
  }
}

// Build outgoing message for OpenAI
function openaiBuildMessage() {
  const msgs = [];

  const systems = [
    { sel: "[data-ai-openai-system]", role: "system" },
    { sel: "[data-ai-openai-user1]", role: "user" },
    { sel: "[data-ai-openai-ai1]", role: "assistant" },
    { sel: "[data-ai-openai-user2]", role: "user" },
    { sel: "[data-ai-openai-ai2]", role: "assistant" }
  ];
  const session = d3.select(".session.selected");
  const input = d3.select("#input");
  const messages = session.selectAll(".message:not(.grayed)");

  const limitDialog = cfg('ai-openai-dialog');
  const limitInput = cfg('ai-openai-input');
  let dialogs = 0;
  let words = 0;

  // System messages
  systems.forEach( x => {
    const n = d3.select(x.sel).node();
    if ( n.value && n.value.length ) {
      if ( n.dataset.words ) {
        words += parseInt( n.dataset.words );
      } else {
        let wc = nWords( n.value );
        n.dataset.words = wc;
        words += wc;
      }
      msgs.push( { n: n, role: x.role, content: n.value } );
    }
  });

  // messages in reverse order
  const revmsgs = [];
  revmsgs.push( { n: input.node(), role: "user", content: input.property("value") } );
  words += nWords( input.property("value") );
  messages.nodes().reverse().forEach( (n) => {
    if ( dialogs < limitDialog && words < limitInput ) {
      let role;
      let val;
      if ( n.dataset.input && n.dataset.input.length ) {
        role = "user";
        val = n.dataset.input;
      } else if ( n.dataset.output && n.dataset.output.length ) {
        role = "assistant";
        val = n.dataset.output;
      }
      if ( role && val ) {
        revmsgs.push( { n: n, role: role, content: val } );
        if ( n.dataset.words ) {
          words += parseInt( n.dataset.words );
        } else {
          let wc = nWords( val );
          n.dataset.words = wc;
          words += wc;
        }
        dialogs++;
      }
    }
  });

  // Build message
  msgs.push( ...revmsgs.reverse() );

  return msgs;
}

// Moderate messages
async function openaiModerateMessage(msgs) {
  // Known status
  let flag = msgs.reduce( (a,b) => ((b.n && b.n.dataset.flag !== undefined) ? ( a | (b.n.dataset.flag === 'true') ) : a ), false);
  let score = msgs.reduce( (a,b) => ((b.n && b.n.dataset.score !== undefined) ? Math.max( a, parseFloat(b.n.dataset.score) ) : a ), 0.0);

  // Moderate only yet unmoderated messages, add the grouped message
  const modMsgs = msgs.filter( x => ( x.n && (x.n.dataset.flag === undefined) && x.content && x.content.length ) );
  if ( modMsgs.length === 0 ) return false;
  if ( msgs.length > 1 ) {
    const full = msgs.map( x => x.content ).join('\n\n');
    modMsgs.push( { content: full } );
  }

  // Endpoint/proxy and authentication
  let url;
  let headers = { "Content-Type": "application/json" };
  const apikey = d3.select("#apikey-openai").property("value");
  if ( apikey ) {
    url = openaiModerationsEndpoint;
    headers["Authorization"] = "Bearer " + apikey;
  } else {
    url = openaiModerationsProxy;
    headers["Authorization"] = "Bearer " + await jwtGet()
  }

  const text = modMsgs.map( x => x.content );
  try {
    const res = await fetch( url, {
      method: "POST",
      mode: "cors",
      headers: headers,
      body: JSON.stringify({
        input: text
      })
    });

    if ( res.ok ) {

      const data = await res.json();

      if ( data && data.results && data.results.length ) {
        data.results.forEach( (x,i) => {
          let flagtmp = Boolean( x.flagged );
          let scoretmp = 0.0;
          Object.keys(x.categories).forEach( key => {
            scoretmp = Math.max( scoretmp, x.category_scores[key] );
          });

          if ( modMsgs[i].n ) {
            modMsgs[i].n.dataset.flag = flagtmp;
            modMsgs[i].n.dataset.score = scoretmp;
          }

          flag |= flagtmp;
          score = Math.max(score,scoretmp);
        });
      }

      d3.select("#flag").classed("selected",flag);
      d3.select("#score").text( "" + Math.round(100 * score) / 100 );
    } else {
      console.error("Error: Moderation API returned ", res.status);
    }

  } catch (error) {
    console.error("Error: Moderation API returned ", error);
  }

  return flag;
}

// Send messages to OpenAI API and handle streamed response
async function openaiSendMessage(node,msgs) {

  // Create a new AbortController instance
  aiController = new AbortController();
  const signal = aiController.signal;

  // Endpoint/proxy and authentication
  let url;
  let headers = { "Content-Type": "application/json" };
  const apikey = d3.select("#apikey-openai").property("value");
  if ( apikey ) {
    url = openaiChatCompletionsEndpoint;
    headers["Authorization"] = "Bearer " + apikey;
  } else {
    url = openaiChatCompletionsProxy;
    headers["Authorization"] = "Bearer " + await jwtGet()
  }

  // Chat completion
  try {
    // Message body
    const body = {
      model: cfg('ai-model'),
      messages: msgs.map( x => {
        const {role,content,name} = x;
        return (name ? {role,content,name} : {role,content});
      }),
      temperature: cfg('ai-openai-temperature'),
      presence_penalty: cfg('ai-openai-presence'),
      frequency_penalty: cfg('ai-openai-frequency'),
      max_tokens: cfg('ai-openai-output'),
      stream: true
    };
    const stop = cfg('ai-openai-stop');
    if ( stop && stop.length ) {
      body.stop = [ stop ];
    }
    const user = cfg('ai-openai-user');
    if ( user && user.length ) {
      body.user = user;
    }
    const isMotionSelected = d3.select("#motion").classed("selected");
    if ( isMotionSelected ) {
      body.tools = [
        {
          "type": "function",
          "function": {
            "name": "move_body",
            "description": "Set the action, still pose and/or mood of your avatar's body in virtual world",
            "parameters": {
              "type": "object",
              "properties": {
                "action": {
                  "type": "string",
                  "enum": Object.keys(site.animations)
                },
                "stillpose": {
                  "type": "string",
                  "enum": Object.keys(site.poses)
                },
                "gesture": {
                  "type": "string",
                  "enum": Object.keys(site.gestures)
                },
                "mood": {
                  "type": "string",
                  "enum": Object.keys(head.animMoods)
                }
              },
              "required": []
            }
          }
        }
      ];
      body.tool_choice = "auto";
      body.parallel_tool_calls = false;
    }

    // Elements
    node.dataset.output = '';
    let tts;
    let fn;

    do {

      // Ready for either text response or a function call
      tts = '';
      fn = { id: '', name: '', arguments: '' };

      // Fetch the response from the OpenAI API
      const res = await fetch( url, {
        method: "POST",
        mode: "cors",
        headers: headers,
        body: JSON.stringify(body),
        signal
      });

      if ( res.ok ) {

        // Read the response as a stream of data
        const reader = res.body.getReader();
        const decoder = new TextDecoder("utf-8");
        let exclude = null; // Exclude object

        while (true) {
          let { done, value } = await reader.read();

          // Extract text data
          if ( value ) {
            decoder.decode(value).split('\n').forEach( data => {
              if ( data.startsWith("data: ") ) {
                let line = data.substring(6).trim();
                if ( line === '[DONE]' ) {
                  done = true;
                } else {
                  let obj;
                  try {
                    obj = JSON.parse( line );
                  } catch(error) {
                    throw new Error( "Error JSON parsing line: " + line );
                  }

                  if ( obj && obj.error ) throw new Error( obj.error.message || ''+res.status );
                  fn.id += obj?.choices?.[0]?.delta?.tool_calls?.[0]?.id || '';
                  fn.name += obj?.choices?.[0]?.delta?.tool_calls?.[0]?.function?.name || '';
                  fn.arguments += obj?.choices?.[0]?.delta?.tool_calls?.[0]?.function?.arguments || '';
                  node.dataset.output += obj?.choices?.[0]?.delta?.content || '';
                  tts += obj?.choices?.[0]?.delta?.content || '';

                }
              }
            });
          }

          // Break, if done
          if (done) {
            if ( fn.id ) {

              // Function call
              body.messages.push({
                role: "assistant",
                content: null,
                tool_calls: [
                  {
                    id: fn.id,
                    type: "function",
                    function: {
                      name: fn.name,
                      arguments: fn.arguments
                    }
                  }
                ]
              });

              // Call the function
              try {
                const m = JSON.parse(fn.arguments);
                motion(m.action, m.stillpose, m.gesture, m.mood);
              } catch(motionError) {
                console.error(motionError);
              }

              // Response
              body.messages.push({
                role: "tool",
                content: "",
                tool_call_id: fn.id
              });

              // Make sure we do not get another function call
              body.tool_choice = "none";
            }

            if ( tts ) {
              if ( cfg('voice-type') === 'eleven' ) {
                await elevenSpeak( tts.trimStart() + " ", node );
              } else if ( cfg('voice-type') === 'microsoft' ) {
                await microsoftSpeak( tts.trimStart() + " ", node );
              } else {
                exclude = excludesProcess(tts,exclude);
                await head.speakText( tts, {
                  lipsyncLang: cfg('voice-lipsync-lang'),
                  ttsVoice: cfg('voice-google-id'),
                  ttsRate: cfg('voice-google-rate'),
                  ttsPitch: cfg('voice-google-pitch')
                }, addText.bind(null,node), exclude.excludes );
              }
            }

            break;
          }

          // Speak
          if ( tts ) {
            let idx = 0;
            ['.','!','?','\n'].forEach( x => {
              let tmp = tts.lastIndexOf(x,idx);
              if ( tmp > idx ) idx = tmp + 1;
            });
            if ( idx > 10 ) {
              let s = tts.substring(0, idx);
              if ( s && s.length ) {
                tts = tts.substring(idx).trimStart();
                if ( cfg('voice-type') === 'eleven' ) {
                  await elevenSpeak( s + " ", node );
                } else if ( cfg('voice-type') === 'microsoft' ) {
                  await microsoftSpeak( s + " ", node );
                } else {
                  exclude = excludesProcess(s,exclude);
                  await head.speakText( s, {
                    lipsyncLang: cfg('voice-lipsync-lang'),
                    ttsVoice: cfg('voice-google-id'),
                    ttsRate: cfg('voice-google-rate'),
                    ttsPitch: cfg('voice-google-pitch')
                  }, addText.bind(null,node), exclude.excludes );
                }
              }
            }
          }

        }

        // Moderate
        let flag = await openaiModerateMessage([{ content: node.dataset.output, n: node }]);

      } else {
        console.error( await res.text() );
        throw new Error( json.error ? json.error.message : ''+res.status );
      }

    } while( fn.id ); // Repeat, if this iteration was a function call

  } catch (error) {
    if ( signal.aborted ) error = "aborted";
    console.error(error);
    addText( node, ' [' + error + ']');
  } finally {
    aiController = null; // Reset the AbortController instance
    if ( elevenSocket ) {
      elevenSpeak("",null);
    }
    microsoftSpeak(null);

    // When this marker has been reached, stop blinking
    head.speakMarker( () => {
      d3.selectAll('.blink').classed("blink",false);
    });
  }
}

// Grok-beta

// Send messages to local LLama API and handle streamed response
async function grokSendMessage(node,msgs) {

  // Create a new AbortController instance
  aiController = new AbortController();
  const signal = aiController.signal;

  // Endpoint/proxy and authentication
  let url;
  let headers = { "Content-Type": "application/json" };
  const apikey = d3.select("#apikey-grok").property("value");
  if ( apikey ) {
    url = grokChatCompletionsEndpoint;
    headers["Authorization"] = "Bearer " + apikey;
  } else {
    url = grokChatCompletionsProxy;
    headers["Authorization"] = "Bearer " + await jwtGet()
  }

  // Chat completion
  try {
    // Message body
    const body = {
      model: cfg('ai-model'),
      messages: msgs.map( x => {
        const {role,content,name} = x;
        return (name ? {role,content,name} : {role,content});
      }),
      temperature: cfg('ai-grok-temperature'),
      presence_penalty: cfg('ai-grok-presence'),
      frequency_penalty: cfg('ai-grok-frequency'),
      max_tokens: cfg('ai-grok-output'),
      stream: true
    };
    const stop = cfg('ai-grok-stop');
    if ( stop && stop.length ) {
      body.stop = [ stop ];
    }
    const user = cfg('ai-grok-user');
    if ( user && user.length ) {
      body.user = user;
    }

    // Elements
    node.dataset.output = '';
    let tts = '';

    // Fetch the response from the Llama.cpp server
    tts = '';
    const res = await fetch( url, {
      method: "POST",
      mode: "cors",
      headers: headers,
      body: JSON.stringify(body),
      signal
    });

    if ( res.ok ) {

      // Read the response as a stream of data
      const reader = res.body.getReader();
      const decoder = new TextDecoder("utf-8");
      let exclude = null; // Exclude object

      while (true) {
        let { done, value } = await reader.read();

        // Extract text data
        if ( value ) {
          decoder.decode(value).split('\n').forEach( data => {
            if ( data.startsWith("data: ") ) {
              let line = data.substring(6).trim();
              if ( line === '[DONE]' ) {
                done = true;
              } else {
                let obj;
                try {
                  obj = JSON.parse( line );
                } catch(error) {
                  throw new Error( "Error JSON parsing line: " + line );
                }

                if ( obj && obj.error ) throw new Error( obj.error.message || ''+res.status );
                node.dataset.output += obj?.choices?.[0]?.delta?.content || '';
                tts += obj?.choices?.[0]?.delta?.content || '';

              }
            }
          });
        }

        // Break, if done
        if (done) {


          if ( tts ) {
            if ( cfg('voice-type') === 'eleven' ) {
              await elevenSpeak( tts.trimStart() + " ", node );
            } else if ( cfg('voice-type') === 'microsoft' ) {
              await microsoftSpeak( tts.trimStart() + " ", node );
            } else {
              exclude = excludesProcess(tts,exclude);
              await head.speakText( tts, {
                lipsyncLang: cfg('voice-lipsync-lang'),
                ttsVoice: cfg('voice-google-id'),
                ttsRate: cfg('voice-google-rate'),
                ttsPitch: cfg('voice-google-pitch')
              }, addText.bind(null,node), exclude.excludes );
            }
          }

          break;
        }

        // Speak
        if ( tts ) {
          let idx = 0;
          ['.','!','?','\n'].forEach( x => {
            let tmp = tts.lastIndexOf(x,idx);
            if ( tmp > idx ) idx = tmp + 1;
          });
          if ( idx > 10 ) {
            let s = tts.substring(0, idx);
            if ( s && s.length ) {
              tts = tts.substring(idx).trimStart();
              if ( cfg('voice-type') === 'eleven' ) {
                await elevenSpeak( s + " ", node );
              } else if ( cfg('voice-type') === 'microsoft' ) {
                await microsoftSpeak( s + " ", node );
              } else {
                exclude = excludesProcess(s,exclude);
                await head.speakText( s, {
                  lipsyncLang: cfg('voice-lipsync-lang'),
                  ttsVoice: cfg('voice-google-id'),
                  ttsRate: cfg('voice-google-rate'),
                  ttsPitch: cfg('voice-google-pitch')
                }, addText.bind(null,node), exclude.excludes );
              }
            }
          }
        }

      }

    } else {
      console.error( await res.text() );
      throw new Error( json.error ? json.error.message : ''+res.status );
    }

  } catch (error) {
    if ( signal.aborted ) error = "aborted";
    console.error(error);
    addText( node, ' [' + error + ']');
  } finally {
    aiController = null; // Reset the AbortController instance
    if ( elevenSocket ) {
      elevenSpeak("",null);
    }
    microsoftSpeak(null);

    // When this marker has been reached, stop blinking
    head.speakMarker( () => {
      d3.selectAll('.blink').classed("blink",false);
    });
  }
}

// Llama

// Send messages to local LLama API and handle streamed response
async function llamaSendMessage(node,msgs) {

  // Create a new AbortController instance
  aiController = new AbortController();
  const signal = aiController.signal;

  // Chat completion
  try {
    // Message body
    const body = {
      model: cfg('ai-model'),
      messages: msgs.map( x => {
        const {role,content,name} = x;
        return (name ? {role,content,name} : {role,content});
      }),
      temperature: cfg('ai-openai-temperature'),
      presence_penalty: cfg('ai-openai-presence'),
      frequency_penalty: cfg('ai-openai-frequency'),
      max_tokens: cfg('ai-openai-output'),
      stream: true
    };
    const stop = cfg('ai-llama-stop');
    if ( stop && stop.length ) {
      body.stop = [ stop ];
    }
    const user = cfg('ai-llama-user');
    if ( user && user.length ) {
      body.user = user;
    }

    // Elements
    node.dataset.output = '';
    let tts = '';

    // Fetch the response from the Llama.cpp server
    tts = '';
    const res = await fetch( llamaChatCompletionsProxy, {
      method: "POST",
      mode: "cors",
      headers: {
        "Content-Type": "application/json",
        "Authorization": "Bearer " + await jwtGet()
      },
      body: JSON.stringify(body),
      signal
    });

    if ( res.ok ) {

      // Read the response as a stream of data
      const reader = res.body.getReader();
      const decoder = new TextDecoder("utf-8");
      let exclude = null; // Exclude object

      while (true) {
        let { done, value } = await reader.read();

        // Extract text data
        if ( value ) {
          decoder.decode(value).split('\n').forEach( data => {
            if ( data.startsWith("data: ") ) {
              let line = data.substring(6).trim();
              if ( line === '[DONE]' ) {
                done = true;
              } else {
                let obj;
                try {
                  obj = JSON.parse( line );
                } catch(error) {
                  throw new Error( "Error JSON parsing line: " + line );
                }

                if ( obj && obj.error ) throw new Error( obj.error.message || ''+res.status );
                node.dataset.output += obj?.choices?.[0]?.delta?.content || '';
                tts += obj?.choices?.[0]?.delta?.content || '';

              }
            }
          });
        }

        // Break, if done
        if (done) {


          if ( tts ) {
            if ( cfg('voice-type') === 'eleven' ) {
              await elevenSpeak( tts.trimStart() + " ", node );
            } else if ( cfg('voice-type') === 'microsoft' ) {
              await microsoftSpeak( tts.trimStart() + " ", node );
            } else {
              exclude = excludesProcess(tts,exclude);
              await head.speakText( tts, {
                lipsyncLang: cfg('voice-lipsync-lang'),
                ttsVoice: cfg('voice-google-id'),
                ttsRate: cfg('voice-google-rate'),
                ttsPitch: cfg('voice-google-pitch')
              }, addText.bind(null,node), exclude.excludes );
            }
          }

          break;
        }

        // Speak
        if ( tts ) {
          let idx = 0;
          ['.','!','?','\n'].forEach( x => {
            let tmp = tts.lastIndexOf(x,idx);
            if ( tmp > idx ) idx = tmp + 1;
          });
          if ( idx > 10 ) {
            let s = tts.substring(0, idx);
            if ( s && s.length ) {
              tts = tts.substring(idx).trimStart();
              if ( cfg('voice-type') === 'eleven' ) {
                await elevenSpeak( s + " ", node );
              } else if ( cfg('voice-type') === 'microsoft' ) {
                await microsoftSpeak( s + " ", node );
              } else {
                exclude = excludesProcess(s,exclude);
                await head.speakText( s, {
                  lipsyncLang: cfg('voice-lipsync-lang'),
                  ttsVoice: cfg('voice-google-id'),
                  ttsRate: cfg('voice-google-rate'),
                  ttsPitch: cfg('voice-google-pitch')
                }, addText.bind(null,node), exclude.excludes );
              }
            }
          }
        }

      }

    } else {
      console.error( await res.text() );
      throw new Error( json.error ? json.error.message : ''+res.status );
    }

  } catch (error) {
    if ( signal.aborted ) error = "aborted";
    console.error(error);
    addText( node, ' [' + error + ']');
  } finally {
    aiController = null; // Reset the AbortController instance
    if ( elevenSocket ) {
      elevenSpeak("",null);
    }
    microsoftSpeak(null);

    // When this marker has been reached, stop blinking
    head.speakMarker( () => {
      d3.selectAll('.blink').classed("blink",false);
    });
  }
}

// Build outgoing message for Google Gemini Pro
function geminiBuildMessage() {
  const msgs = [];

  const systems = [
    { sel: "[data-ai-gemini-system]", role: "system" },
    { sel: "[data-ai-gemini-user1]", role: "user" },
    { sel: "[data-ai-gemini-ai1]", role: "model" },
    { sel: "[data-ai-gemini-user2]", role: "user" },
    { sel: "[data-ai-gemini-ai2]", role: "model" }
  ];
  const session = d3.select(".session.selected");
  const input = d3.select("#input");
  const messages = session.selectAll(".message:not(.grayed)");

  const limitDialog = cfg('ai-gemini-dialog');
  const limitInput = cfg('ai-gemini-input');
  let dialogs = 0;
  let words = 0;

  // System messages
  systems.forEach( x => {
    const n = d3.select(x.sel).node();
    if ( n.value && n.value.length ) {
      if ( n.dataset.words ) {
        words += parseInt( n.dataset.words );
      } else {
        let wc = nWords( n.value );
        n.dataset.words = wc;
        words += wc;
      }
      msgs.push( { n: n, role: x.role, content: n.value } );
    }
  });

  // messages in reverse order
  const revmsgs = [];
  revmsgs.push( { n: input.node(), role: "user", content: input.property("value") } );
  words += nWords( input.property("value") );
  messages.nodes().reverse().forEach( (n) => {
    if ( dialogs < limitDialog && words < limitInput ) {
      let role;
      let val;
      if ( n.dataset.input && n.dataset.input.length ) {
        role = "user";
        val = n.dataset.input;
      } else if ( n.dataset.output && n.dataset.output.length ) {
        role = "model";
        val = n.dataset.output;
      }
      if ( role && val ) {
        revmsgs.push( { n: n, role: role, content: val } );
        if ( n.dataset.words ) {
          words += parseInt( n.dataset.words );
        } else {
          let wc = nWords( val );
          n.dataset.words = wc;
          words += wc;
        }
        dialogs++;
      }
    }
  });

  // Build message
  msgs.push( ...revmsgs.reverse() );

  return msgs;
}

// Send messages to Gemini API and handle streamed response
async function geminiSendMessage(node,msgs) {

  // Create a new AbortController instance
  aiController = new AbortController();
  const signal = aiController.signal;

  // Elements
  node.dataset.output = '';

  // Chat completion
  try {

    // Message body
    const body = {
      contents: [],
      safetySettings: [
        { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
        { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
        { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
        { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
      ],
      generationConfig: {
        temperature: cfg('ai-gemini-temperature'),
        maxOutputTokens: cfg('ai-gemini-output'),
        topP: cfg('ai-gemini-topp'),
        topK: cfg('ai-gemini-topk'),
        candidateCount: 1
      }
    };

    // Add messages
    // Make sure multiturn messages alternate between user and model
    let nextRole = 'user';
    msgs.forEach( x => {
      if ( x.role === "system" ) {
        body["systemInstruction"] = { "parts": [ { "text": x.content } ] };
      } else {
        if ( x.role !== nextRole ) {
          body.contents.push( { role: nextRole, "parts": { "text": "..." } } )
        }
        body.contents.push( { role: x.role, "parts": { "text": x.content } } );
        nextRole = x.role === 'user' ? 'model' : 'user';
      }
    });

    // Stop
    const stop = cfg('ai-gemini-stop');
    if ( stop && stop.length ) {
      body.generationConfig.stopSequences = [ stop ];
    }

    // Function calling
    const isMotionSelected = d3.select("#motion").classed("selected");
    if ( isMotionSelected ) {
      body.tools = [{
        functionDeclarations: [{
          "name": "move_body",
          "description": "Set the action, still pose, gesture and/or mood of your avatar's body in virtual world",
          "parameters": {
            "type": "object",
            "properties": {
              "action": {
                "type": "STRING",
                format: "enum",
                nullable: true,
                "enum": Object.keys(site.animations)
              },
              "stillpose": {
                "type": "STRING",
                format: "enum",
                nullable: true,
                "enum": Object.keys(site.poses)
              },
              "gesture": {
                "type": "STRING",
                format: "enum",
                nullable: true,
                "enum": Object.keys(site.gestures)
              },
              "mood": {
                "type": "STRING",
                format: "enum",
                nullable: true,
                "enum": Object.keys(head.animMoods)
              }
            },
            "required": []
          }
        }]
      }];
    }

    // Function loop
    let fn;
    do {

      fn = null;

      // Endpoint/proxy and authentication
      let url;
      let headers = { "Content-Type": "application/json; charset=utf-8" };
      const apikey = d3.select("#apikey-gemini").property("value");
      if ( apikey ) {
        url = geminiEndpoint + cfg("ai-model") + ':streamGenerateContent?alt=sse';
        headers["x-goog-api-key"] = apikey;
      } else {
        url = geminiProxy + cfg("ai-model") + ':streamGenerateContent?alt=sse';
        headers["Authorization"] = "Bearer " + await jwtGet()
      }

      // Fetch the response from the Vertex AI API
      const res = await fetch( url, {
        method: "POST",
        headers: headers,
        body: JSON.stringify(body),
        signal
      });

      if ( res.ok ) {

        // Read the response as a stream of data
        const reader = res.body.getReader();
        const decoder = new TextDecoder("utf-8");
        let tts = "";

        while (true) {
          const { done, value } = await reader.read();

          // Extract text data
          if ( value ) {
            decoder.decode(value).split('\n').forEach( data => {
              if ( data.startsWith("data: ") ) {
                let finish;
                try {
                  const obj = JSON.parse( data.substring(6).trim() );
                  const canditate = obj?.candidates?.[0];
                  finish = canditate?.finishReason || 'STOP';
                  fn = canditate?.content?.parts?.[0]?.functionCall;
                  if ( !fn ) {
                    node.dataset.markdown += canditate?.content?.parts?.[0]?.text || '';
                    node.dataset.output += canditate?.content?.parts?.[0]?.text || '';
                    tts += canditate?.content?.parts?.[0]?.text || '';
                  }

                } catch(error) {
                  console.log( "Error JSON parsing data: " + data );
                }
                if ( finish !== 'STOP' ) {
                  throw new Error("Stopped for " + finish + ".");
                }
              }
            });
          }

          // Speak and break when done
          if ( done ) {
            if ( tts ) {
              if ( cfg('voice-type') === 'eleven' ) {
                await elevenSpeak( tts + " ", node );
              } else if ( cfg('voice-type') === 'microsoft' ) {
                await microsoftSpeak( tts + " ", node );
              } else {
                await head.speakText( tts, {
                  lipsyncLang: cfg('voice-lipsync-lang'),
                  ttsVoice: cfg('voice-google-id'),
                  ttsRate: cfg('voice-google-rate'),
                  ttsPitch: cfg('voice-google-pitch')
                }, addText.bind(null,node) );
              }
            }
            break;
          } else {
            let ndx = 0;
            ['.','!','?','\n'].forEach( x => {
              let tmp = tts.lastIndexOf(x,ndx);
              if ( tmp > ndx ) ndx = tmp + 1;
            });
            if ( ndx > 10 ) {
              if ( cfg('voice-type') === 'eleven' ) {
                await elevenSpeak( tts.substring(0, ndx) + " ", node );
              } else if ( cfg('voice-type') === 'microsoft' ) {
                await microsoftSpeak( tts.substring(0, ndx) + " ", node );
              } else {
                await head.speakText( tts.substring(0, ndx), {
                  lipsyncLang: cfg('voice-lipsync-lang'),
                  ttsVoice: cfg('voice-google-id'),
                  ttsRate: cfg('voice-google-rate'),
                  ttsPitch: cfg('voice-google-pitch')
                }, addText.bind(null,node) );
              }
              tts = tts.substring(ndx).trimStart();
            }
          }

        }

      } else {
        console.error( await res.text() );
        throw new Error( json.error ? json.error.message : ''+res.status );
      }

      // Call function
      if ( fn ) {

        // Add function call to body
        body.contents.push( {
          role: "model",
          parts: [
            {
              functionCall: {
                name: "move_body",
                args: {
                  "action": fn.args?.["action"],
                  "stillpose": fn.args?.["stillpose"],
                  "gesture": fn.args?.["gesture"],
                  "mood": fn.args?.["mood"]
                }
              }
            }
          ]
        });

        // Call function
        try {
          motion(fn.args?.["action"], fn.args?.["stillpose"], fn.args?.["gesture"], fn.args?.["mood"]);
        } catch(motionError) {
          console.error(motionError);
        }

        // Add response
        body.contents.push({
          role: "function",
          parts: [
            {
              functionResponse: {
                name: "move_body",
                response: {
                  "status": "ok"
                }
              }
            }
          ]
        });

        // Instruct not to make another call
        body.toolConfig = { functionCallingConfig: { mode: "NONE" } };

      }

    } while( fn ); // Repeat, if this iteration was a function call

  } catch (error) {
    if ( signal.aborted ) error = "aborted";
    console.error(error);
    addText( node, ' [' + error + ']');
  } finally {
    aiController = null; // Reset the AbortController instance
    if ( elevenSocket ) {
      elevenSpeak("",null);
    }
    microsoftSpeak(null);

    // When this marker has been reached, stop blinking
    head.speakMarker( () => {
      d3.selectAll('.blink').classed("blink",false);
    });
  }
}


// Add new message to UI
function addMessage(user = false) {
  const session = d3.select(".session.selected");
  const message = session.append("div");
  message.classed("message", true)
    .classed("user",user)
    .classed("blink",!user);

  // Add selection
  const toolbarLeft = message.append("div");
  toolbarLeft.classed("toolbar-left", true);
  toolbarLeft.append("div")
    .classed("command",true)
    .classed("select", true )
    .on('click', function(ev) {
      let e = d3.select(this);
      let mode = !e.classed("selected");
      e.classed("selected", mode );
      d3.select(this.parentNode.parentNode).classed("grayed", mode );
    })
    .html(svgSelect);

  if ( user ) {
    const toolbarRight = message.append("div");
    toolbarRight.classed("toolbar-right", true);
    toolbarRight.append("div")
      .classed("command", true)
      .on('click', function(ev) {
        let n = this.parentNode.parentNode;
        const text = d3.select(n).attr('data-input');
        while(n) {
          let e = d3.select(n);
          e.classed("grayed",true);
          e.select(".select").classed("selected", true );
          n = n.nextSibling;
        }
        let node = d3.select("#input").property("value",text).dispatch("change").node();
        node.scrollTop = node.scrollHeight;
        node.focus();
      })
      .html(svgRepost);

  } else {
    const toolbarRight = message.append("div");
    toolbarRight.classed("toolbar-right", true);
    toolbarRight.append("div")
      .classed("command", true)
      .on('click', function(ev) {
        const e = d3.select(this.parentNode.parentNode);
        let text = e.attr("data-output");
        if ( text && text.length ) {
          if ( cfg('voice-type') === 'eleven' ) {
            elevenSpeak( text + " " );
            elevenSpeak( "" );
          } else if ( cfg('voice-type') === 'microsoft' ) {
            microsoftSpeak( text );
            microsoftSpeak( null );
          } else {
            head.speakText( text, {
              lipsyncLang: cfg('voice-lipsync-lang'),
              ttsVoice: cfg('voice-google-id'),
              ttsRate: cfg('voice-google-rate'),
              ttsPitch: cfg('voice-google-pitch')
            } );
          }
        }
      })
      .html(svgSpeak);

    toolbarRight.append("div")
      .classed("command", true)
      .on('click', function(ev) {
        head.stopSpeaking();
        // Abort the fetch request by calling abort() on the AbortController instance
        if (aiController) {
          aiController.abort();
          aiController = null;
        }
      })
      .html(svgStop);
  }

  message.append('p');

  const nodeSessions = d3.select("#right-sessions").node();
  nodeSessions.scrollTop = nodeSessions.scrollHeight;

  return message.node();
}

// Add text to session
function addText(node,s) {
  const nodeSessions = d3.select("#right-sessions").node();
  const onbottom = Math.abs( nodeSessions.scrollHeight - nodeSessions.scrollTop - nodeSessions.clientHeight) < 20;
  let last = node.lastElementChild;
  let markdown = (last.dataset.markdown || '') + s;
  let ndx = markdown.lastIndexOf('\n\n');
  if ( ndx === -1 ) {
    // Add to the existing paragraph
    last.innerHTML = dompurify.sanitize(marked.parseInline( markdown, markedOptions ));
    last.dataset.markdown = markdown;
  } else {
    // First part into the existing paragraph
    let md = markdown.substring(0, ndx);
    last.innerHTML = dompurify.sanitize(marked.parseInline( md, markedOptions ));
    last.dataset.markdown = md;

    // Last part into a new paragraph
    md = markdown.substring(ndx + 2);
    last = node.appendChild( document.createElement('p') );
    last.innerHTML = dompurify.sanitize(marked.parseInline( md, markedOptions ));
    last.dataset.markdown = md;
  }
  if ( onbottom ) nodeSessions.scrollTop = nodeSessions.scrollHeight;
}

// External speak
async function speak(s) {
  let node = addMessage(false);
  if ( cfg('voice-type') === 'eleven' ) {
    await elevenSpeak( s, node );
    await elevenSpeak( "", node );
  } else if ( cfg('voice-type') === 'microsoft' ) {
    await microsoftSpeak( s, node );
    await microsoftSpeak(null);
  } else {
    await head.speakText( s, {
      lipsyncLang: cfg('voice-lipsync-lang'),
      ttsVoice: cfg('voice-google-id'),
      ttsRate: cfg('voice-google-rate'),
      ttsPitch: cfg('voice-google-pitch')
    }, addText.bind(null,node) );
  }

  // When this marker has been reached, stop blinking
  head.speakMarker( () => {
    d3.selectAll('.blink').classed("blink",false);
  });
}
window.talkingheadSpeak = speak;

// Select an directory entry
function entrySelect() {
  reconnectEffect();
  const e = d3.select(this);
  const id = parseInt( e.attr("data-session") );
  d3.selectAll("[data-session]").classed('selected',false);
  e.classed('selected',true);
  loadConfig(id);
  i18nTranslate();
  d3.selectAll("[data-range]").dispatch("change");
}

// Move directory entry
function entryMove() {
  const e = d3.select(this);
  const n = e.node().parentElement; // Entry
  const id = parseInt( n.id.split('-')[1] );
  const directory = d3.select("#directory").node();
  const direction = e.attr("data-entry-move");
  let session = CFG.session;

  if ( direction === 'up' ) {

    // Swap configuration
    var tmp = CFG.sessions[id];
    CFG.sessions[id] = CFG.sessions[id-1];
    CFG.sessions[id-1] = tmp;

    // Swap directory entries
    d3.select(n)
      .property("id","entry-"+(id-1))
      .select("[data-session]")
      .attr("data-session",(id-1));
    d3.select(n.previousElementSibling)
      .property("id","entry-"+id)
      .select("[data-session]")
      .attr("data-session",id);
    directory.insertBefore(n,n.previousElementSibling);
    if ( session === id ) {
      session = id - 1;
    } else if ( session === (id-1) ) {
      session = id;
    }

    // Swap sessions ids (no need to swap their places)
    const s1 = d3.select("#session-"+id);
    const s2 = d3.select("#session-"+(id-1));
    s1.property("id","session-"+(id-1) );
    s2.property("id","session-"+id );

  } else if ( direction === 'down' ) {

    // Swap configuration
    var tmp = CFG.sessions[id];
    CFG.sessions[id] = CFG.sessions[id+1];
    CFG.sessions[id+1] = tmp;

    // Swap directory entries
    d3.select(n)
      .property("id","entry-"+(id+1))
      .select("[data-session]")
      .attr("data-session",(id+1));
    d3.select(n.nextElementSibling)
      .property("id","entry-"+id)
      .select("[data-session]")
      .attr("data-session",id);
    directory.insertBefore(n.nextElementSibling,n);
    if ( session === id ) {
      session = id + 1;
    } else if ( session === (id+1) ) {
      session = id;
    }

    // Swap sessions ids (no need to swap their places)
    const s1 = d3.select("#session-"+id);
    const s2 = d3.select("#session-"+(id+1));
    s1.property("id","session-"+(id+1) );
    s2.property("id","session-"+id );

  }

  // Save new configuration and load the session
  saveConfig();
  loadConfig(session);
  i18nTranslate();
  d3.selectAll("[data-range]").dispatch("change");
}

// Turn on effect
function turnOnEffect() {
  d3.selectAll('.starttransparent').nodes().forEach( panel => {
    const steps = 5 + Math.floor( Math.random() * 10 );
    const ops = [];
    for( let i=steps; i > 0; i-- ) {
      ops.push( { opacity: Math.random() } );
    }
    ops.push( { opacity: 1 } );
    const timing = {
      duration: Math.floor( Math.random() * 2000 ) + 300,
      fill: "forwards"
    };
    panel.animate(ops,timing);
  });
}

// Reconnect effect
function reconnectEffect() {

  // Turn off
  d3.selectAll("#avatar,#view").style("opacity","0");
  d3.select("#left").classed("glow",false);

  // Turn on
  setTimeout( () => {
    d3.selectAll("#avatar,#view").style("opacity","1");
    d3.select("#left").classed("glow",true);
  }, 1000);

}

// Talking Head
let head;
let morphTimer = null;

function headLoaded(firsttime=false) {

  // Populate emoji tester
  if ( firsttime ) {
    const elEmojis = d3.select("#emojis");
    for( let [em,x] of Object.entries(head.animEmojis) ) {
      elEmojis.append("div")
        .classed("emoji", true)
        .on('click', function(ev) {
          const e = d3.select(this);
          const name = e.text();

          // Clear timeouts
          if ( morphTimer ) {
            clearTimeout(morphTimer);
            morphTimer = null;
          }

          // Clear morphs
          head.getMorphTargetNames().forEach( mt => {
            const el = d3.select('#' + CSS.escape(mt));
            if ( !el.empty() ) {
              let v = testerGetValue(mt,null);
              if ( parseFloat(el.property("value")) !== v ) {
                el.property("value",v);
                d3.select(el.node().nextElementSibling).html(testerGetLabel(mt,v));
                head.setFixedValue(mt,testerGetFixedValue(mt,v));
              }
            }
          });

          const selected = e.classed("selected");
          d3.selectAll(".emoji").classed("selected",false);
          if ( selected ) {
            d3.selectAll(".emoji").classed("selected",false);
            testerUpdateMorphData();
          } else {
            e.classed("selected",true);

            // Animate
            head.playGesture(name,3);

            morphTimer = setTimeout( () => {
              morphTimer = null;
              const o = head.animEmojis[name];
              if ( o ) {
                head.getMorphTargetNames().forEach( mt => {
                  let val = null;
                  if ( o.vs &&  o.vs[mt] ) {
                    val = o.vs[mt][o.vs[mt].length-1];
                    if ( Array.isArray(val) ) val = val[val.length-1];
                  }
                  const el = d3.select('#' + CSS.escape(mt));
                  if ( !el.empty() ) {
                    let v = testerGetValue(mt,val);
                    if ( parseFloat(el.property("value")) !== v ) {
                      el.property("value",v);
                      d3.select(el.node().nextElementSibling).html(testerGetLabel(mt,v));
                      head.setFixedValue(mt,testerGetFixedValue(mt,v));
                    }
                  }
                });
                testerUpdateMorphData();
              }
            }, 3500);
          }
        })
        .html(em);
    }
  }

  // Populate morph targets (a.k.a. blend shapes)
  const elMorphs = d3.select("#morphs");
  elMorphs.html("");
  head.getMorphTargetNames().forEach( mt => {
    let v = head.getFixedValue(mt);

    const morph = elMorphs.append("div")
      .classed("row", true)
      .classed("morph", true);

    morph.append("div")
      .classed("text", true)
      .classed("label", true)
      .html(mt);

    morph.append("input")
      .property("id", mt)
      .property("type", "range")
      .property("min", testerGetMin(mt))
      .property("max", testerGetMax(mt))
      .property("step", testerGetStep(mt))
      .property("value", testerGetValue(mt,v))
      .on('input change keyup', function(ev) {
        const e = d3.select(this);
        const mt = e.property("id");
        let v = parseFloat(e.property("value"));
        d3.select(e.node().nextElementSibling).html(testerGetLabel(mt,v));
        head.setFixedValue(mt,testerGetFixedValue(mt,v));
        testerUpdateMorphData();
      });

    morph.append("div")
      .classed("text", true)
      .html(testerGetLabel(mt,v));
  });

  // Populate skinned meshes
  const elSkinnedMeshes = d3.select("#skinnedmeshes");
  elSkinnedMeshes.html("");
  head.armature.traverse( x => {
    if ( x.isSkinnedMesh ) {
      elSkinnedMeshes.append("div")
        .classed("command", true)
        .classed("selected", x.visible )
        .on('click', function(ev) {
          const e = d3.select(this);
          const sel = e.classed('selected');
          e.classed('selected', !sel)
          x.visible = !sel;
        })
        .html(x.name);
    }
  });

  // Populate dynamic bones
  const elBonesHelpers = d3.select("#boneshelpers");
  const elBonesSelect = d3.select("#bonesselect");
  elBonesHelpers.html("");
  elBonesSelect.html("");
  const names = head.dynamicbones?.getBoneNames();
  if ( names && names.length ) {

    // Director
    d3.select("#bonesfeaturedynamic")
      .on("click", null)
      .on("click", function(ev) {
        const e = d3.select(this);
        const sel = !e.classed('selected');
        e.classed('selected', sel);
        if ( sel === true ) {
          head.dynamicbones.start();
        } else {
          head.dynamicbones.stop();
        }
      })
      .classed("selected", true)
      .classed("disabled", false);
    d3.select("#bonesfeatureexcludes")
      .on("click", null)
      .on("click", function(ev) {
        const e = d3.select(this);
        const sel = !e.classed('selected');
        e.classed('selected', sel);
        head.dynamicbones.setOptionValue("isExcludes",sel);
      })
      .classed("selected", true)
      .classed("disabled", false);
    d3.select("#bonesfeaturepivots")
      .on("click", null)
      .on("click", function(ev) {
        const e = d3.select(this);
        const sel = !e.classed('selected');
        e.classed('selected', sel);
        head.dynamicbones.setOptionValue("isPivots",sel);
      })
      .classed("selected", true)
      .classed("disabled", false);
    d3.select("#bonesfeaturelimits")
      .on("click", null)
      .on("click", function(ev) {
        const e = d3.select(this);
        const sel = !e.classed('selected');
        e.classed('selected', sel);
        head.dynamicbones.setOptionValue("isLimits",sel);
      })
      .classed("selected", true)
      .classed("disabled", false);

    // Bone testers
    d3.selectAll(".bonetester").on("click", function(ev) {
      const e = d3.select(this);
      const name = d3.select(".dynamicbone.selected").text();
      const data = head?.dynamicbones?.data?.find( x => x.name === name );
      if ( data ) {
        let dir = 0;
        switch( e.text() ) {
          case 'x': dir = 0; break;
          case 'y': dir = 1; break;
          case 'z': dir = 2; break;
          case 't': dir = 3;
        }
        data.v[dir] = 100;
      }
    });

    // Show all
    elBonesHelpers.append("div")
      .property("id","bonehelpershowall")
      .classed("command", true)
      .on('click', function(ev) {
        const e = d3.select(this);
        const sel = e.classed('selected');
        e.classed('selected', !sel)
        if ( sel ) {
          head.dynamicbones.showHelpers(false);
        } else {
          head.dynamicbones.showHelpers(true);
        }
      })
      .html("ALL");

    names.forEach( (name,i) => {

      elBonesHelpers.append("div")
        .classed("command", true)
        .classed("bonehelper", true)
        .classed("selected", head.dynamicbones.getValue(name,"helper") || false )
        .on('click', function(ev) {
          const e = d3.select(this);
          const sel = e.classed('selected');
          e.classed('selected', !sel)
          head.dynamicbones.setValue(name,"helper",!sel);
        })
        .html(name);

      elBonesSelect.append("div")
        .classed("command", true)
        .classed("dynamicbone", true)
        .classed("selected", i === 0)
        .on('click', function(ev) {
          const e = d3.select(this);
          d3.selectAll(".dynamicbone").classed('selected',false);
          e.classed('selected',true);

          const type = head.dynamicbones.getValue(name,"type");
          d3.selectAll(".bonetype").classed('selected',false);
          d3.select("#bonetype"+type).classed('selected',true);

          let k = head.dynamicbones.getValue(name,"stiffness");
          d3.select("#stiffnesslock").classed("selected", !Number.isNaN(k) );
          if ( !Number.isNaN(k) ) {
            k = Array(4).fill(k);
          }
          d3.select('#stiffnessx').property('value', k[0] ).node().nextElementSibling.textContent = k[0];
          d3.select('#stiffnessy').property('value', k[1] ).node().nextElementSibling.textContent = k[1];
          d3.select('#stiffnessz').property('value', k[2] ).node().nextElementSibling.textContent = k[2];
          d3.select('#stiffnesst').property('value', k[3] ).node().nextElementSibling.textContent = k[3];

          let c = head.dynamicbones.getValue(name,"damping");
          d3.select("#dampinglock").classed("selected", !Number.isNaN(c) );
          if ( !Number.isNaN(k) ) {
            c = Array(4).fill(c);
          }
          d3.select('#dampingx').property('value', c[0] ).node().nextElementSibling.textContent = c[0];
          d3.select('#dampingy').property('value', c[1] ).node().nextElementSibling.textContent = c[1];
          d3.select('#dampingz').property('value', c[2] ).node().nextElementSibling.textContent = c[2];
          d3.select('#dampingt').property('value', c[3] ).node().nextElementSibling.textContent = c[3];

          const ext = head.dynamicbones.getValue(name,"external") || 1.0;
          d3.select('#external').property('value', ext ).node().nextElementSibling.textContent = ext;

          let l = head.dynamicbones.getValue(name,"limits");
          if ( l ) {
            if ( !l[0] ) l[0] = [null,null];
            if ( !l[1] ) l[1] = [null,null];
            if ( !l[2] ) l[2] = [null,null];
            if ( !l[3] ) l[3] = [null,null];
          } else {
            l = [[null,null],[null,null],[null,null],[null,null]];
          }
          l = l.flat();
          [ '#limitsx1','#limitsx2','#limitsy1','#limitsy2','#limitsz1','#limitsz2','#limitst1','#limitst2' ].forEach( (x,i) => {
            d3.select(x+'null').classed("selected", l[i] !== null );
            d3.select(x)
              .property("value",l[i])
              .classed("disabled", l[i] === null )
              .node().nextElementSibling.textContent = l[i] === null ? "" : (l[i] + ' m');
          });

          const deltal = head.dynamicbones.getValue(name,"deltaLocal") || [0,0,0];
          d3.select('#deltalx').property('value', deltal[0] ).node().nextElementSibling.textContent = deltal[0];
          d3.select('#deltaly').property('value', deltal[1] ).node().nextElementSibling.textContent = deltal[1];
          d3.select('#deltalz').property('value', deltal[2] ).node().nextElementSibling.textContent = deltal[2];

          const deltaw = head.dynamicbones.getValue(name,"deltaWorld") || [0,0,0];
          d3.select('#deltawx').property('value', deltaw[0] ).node().nextElementSibling.textContent = deltaw[0];
          d3.select('#deltawy').property('value', deltaw[1] ).node().nextElementSibling.textContent = deltaw[1];
          d3.select('#deltawz').property('value', deltaw[2] ).node().nextElementSibling.textContent = deltaw[2];

          const pivot = head.dynamicbones.getValue(name,"pivot") || false;
          d3.select("#pivot").classed("selected",pivot);

        })
        .html(name);
    });

    d3.select('#bonesdata').property("value", JSON.stringify( head.dynamicbones.getConfig() ) );

    // Change type
    d3.selectAll(".bonetype")
      .classed("disabled", false)
      .on('click', null)
      .on('click', function(ev) {
        const e = d3.select(this);
        d3.selectAll(".bonetype").classed('selected',false);
        e.classed('selected',true);
        const name = d3.select(".dynamicbone.selected").text();
        const type = e.text();
        head.dynamicbones.setValue(name,"type",type);
        d3.select('#bonesdata').property("value", JSON.stringify( head.dynamicbones.getConfig() ) );
      });

    // Change stiffness
    d3.selectAll(".stiffness")
      .classed("disabled", false)
      .on('input.update change.update keyup.update', null)
      .on('input.update change.update keyup.update', function(ev) {
        const e = d3.select(this);
        const name = d3.select(".dynamicbone.selected").text();
        const lock = d3.select("#stiffnesslock").classed("selected");
        if ( lock ) {
          d3.selectAll(".stiffness").property('value',e.property('value')).nodes().forEach( x => {
            x.nextElementSibling.textContent = e.property('value');
          });
        }
        head.dynamicbones.setValue(name,"stiffness",[
          parseFloat( d3.select('#stiffnessx').property('value') ),
          parseFloat( d3.select('#stiffnessy').property('value') ),
          parseFloat( d3.select('#stiffnessz').property('value') ),
          parseFloat( d3.select('#stiffnesst').property('value') )
        ]);
        d3.select('#bonesdata').property("value", JSON.stringify( head.dynamicbones.getConfig() ) );
      });

    // Change damping
    d3.selectAll(".damping")
      .classed("disabled", false)
      .on('input.update change.update keyup.update', null)
      .on('input.update change.update keyup.update', function(ev) {
        const e = d3.select(this);
        const name = d3.select(".dynamicbone.selected").text();
        const lock = d3.select("#dampinglock").classed("selected");
        if ( lock ) {
          d3.selectAll(".damping").property('value',e.property('value')).nodes().forEach( x => {
            x.nextElementSibling.textContent = e.property('value');
          });
        }
        head.dynamicbones.setValue(name,"damping",[
          parseFloat( d3.select('#dampingx').property('value') ),
          parseFloat( d3.select('#dampingy').property('value') ),
          parseFloat( d3.select('#dampingz').property('value') ),
          parseFloat( d3.select('#dampingt').property('value') )
        ]);
        d3.select('#bonesdata').property("value", JSON.stringify( head.dynamicbones.getConfig() ) );
      });

    // Locks
    d3.selectAll("#stiffnesslock,#dampinglock")
      .classed("disabled", false)
      .on("click",null)
      .on('click', function(ev) {
        const e = d3.select(this);
        const sel = e.classed('selected');
        e.classed('selected', !sel);
        d3.select(this.parentNode).select("input").dispatch("change");
      });

    // Change external
    d3.select("#external")
      .classed("disabled", false)
      .on('input.update change.update keyup.update', null)
      .on('input.update change.update keyup.update', function(ev) {
        const name = d3.select(".dynamicbone.selected").text();
        head.dynamicbones.setValue(name,"external",
          parseFloat( d3.select('#external').property('value') )
        );
        d3.select('#bonesdata').property("value", JSON.stringify( head.dynamicbones.getConfig() ) );
      });

    // Change limits
    d3.selectAll(".limits")
      .classed("disabled", false)
      .on('input.update change.update keyup.update', null)
      .on('input.update change.update keyup.update', function(ev) {
        let val = [ '#limitsx1','#limitsx2','#limitsy1','#limitsy2','#limitsz1','#limitsz2','#limitst1','#limitst2' ].map( (x,i) => {
          return d3.select(x+'null').classed("selected" ) ? parseFloat( d3.select(x).property("value") ) : null;
        });
        val = [
          [val[0],val[1]],
          [val[2],val[3]],
          [val[4],val[5]],
          [val[6],val[7]]
        ];
        val = val.map( x => ( x[0] === null && x[1] === null ) ? null : x );
        if ( val.every( x => x === null ) ) val = null;
        const name = d3.select(".dynamicbone.selected").text();
        head.dynamicbones.setValue(name, "limits", val );
        d3.select('#bonesdata').property("value", JSON.stringify( head.dynamicbones.getConfig() ) );
      });

    // Change delta local
    d3.selectAll(".deltal")
      .classed("disabled", false)
      .on('input.update change.update keyup.update', null)
      .on('input.update change.update keyup.update', function(ev) {
        const name = d3.select(".dynamicbone.selected").text();
        head.dynamicbones.setValue(name,"deltaLocal",[
          parseFloat( d3.select('#deltalx').property('value') ),
          parseFloat( d3.select('#deltaly').property('value') ),
          parseFloat( d3.select('#deltalz').property('value') )
        ]);
        d3.select('#bonesdata').property("value", JSON.stringify( head.dynamicbones.getConfig() ) );
      });

    // Change delta world
    d3.selectAll(".deltaw")
      .classed("disabled", false)
      .on('input.update change.update keyup.update', null)
      .on('input.update change.update keyup.update', function(ev) {
        const name = d3.select(".dynamicbone.selected").text();
        head.dynamicbones.setValue(name,"deltaWorld",[
          parseFloat( d3.select('#deltawx').property('value') ),
          parseFloat( d3.select('#deltawy').property('value') ),
          parseFloat( d3.select('#deltawz').property('value') )
        ]);
        d3.select('#bonesdata').property("value", JSON.stringify( head.dynamicbones.getConfig() ) );
      });

    // Change pivot
    d3.select("#pivot")
      .classed("disabled", false)
      .on('click', null)
      .on('click', function(ev) {
        const e = d3.select(this);
        const sel = e.classed('selected');
        e.classed('selected', !sel)
        const name = d3.select(".dynamicbone.selected").text();
        head.dynamicbones.setValue(name,"pivot",!sel);
        d3.select('#bonesdata').property("value", JSON.stringify( head.dynamicbones.getConfig() ) );
      });

    // Select first bone
    d3.select('.dynamicbone').dispatch("click");

  } else {

    d3.selectAll("#bonesfeaturedynamic,#bonesfeatureexcludes,#bonesfeaturepivots,#bonesfeaturelimits,.bonetype,#pivot,#stiffnesslock,#dampinglock")
      .classed("selected", false)
      .classed("disabled", true)
      .on("click", null);

    let row = elBonesHelpers.append("div")
      .classed("row", true)
      .classed("bone", true);

    row.append("div")
      .classed("text", true)
      .classed("label", true)
      .html("N/A");

    row = elBonesSelect.append("div")
      .classed("row", true)
      .classed("bone", true);

    row.append("div")
      .classed("text", true)
      .classed("label", true)
      .html("N/A");

    d3.selectAll(".stiffness,.damping,#external,.limits,.deltal,.deltaw")
      .classed("disabled", true)
      .on('input.update change.update keyup.update', null);

    d3.select('#bonesdata').property("value", "");
  }

  // Unlock Web Audio API
  if ( firsttime ) {
    if ( head.audioCtx.state === 'suspended' ) {
      if ( 'ontouchstart' in window ) {
        let unlockWebAudioAPI = function() {
          head.audioCtx.resume().then( () => {
            document.body.removeEventListener('touchstart', unlockWebAudioAPI);
            document.body.removeEventListener('touchend', unlockWebAudioAPI);
          });
        };
        document.body.addEventListener('touchstart', unlockWebAudioAPI, false);
        document.body.addEventListener('touchend', unlockWebAudioAPI, false);
      }
    }

    setTimeout( () => {
      turnOnEffect();
      reconnectEffect();
      loadConfig();
    }, 1000);
  }
}

// Update progress bar
let progressTimeout;
function progressUpdate(ev) {
  if ( progressTimeout ) {
    clearTimeout(progressTimeout);
    progressTimeout = null;
  } else {
    d3.select("#loading").style("display","block");
  }
  let hideMs = 1000;
  if ( ev.lengthComputable ) {
    let val = Math.min(100,Math.round(ev.loaded/ev.total * 100 ));
    d3.select("#loading-top").style("clip-path", "inset(0 " + (100-val) + "% 0 0)");
    d3.selectAll("#loading-value").text( val + "%" );
    if ( val<100 ) hideMs = 3000;
  } else {
    d3.select("#loading-top").style("clip-path", "inset(0 0 0 0)");
    d3.selectAll("#loading-value").text( "" + ev.loaded );
  }
  progressTimeout = setTimeout( () => {
    d3.select("#loading").style("display","none");
    progressTimeout = null;
  }, hideMs);
}

// Update progress bar using media loading progress
function progressMedia() {
  let bf = this.buffered;
  let dur = this.duration;
  let state = this.readyState;
  if ( bf && bf.length && !Number.isNaN(dur) && dur < Infinity && state > 0 && state < 4) {
    progressUpdate( {
      loaded: bf.end(bf.length-1) - bf.start(bf.length-1),
      total: dur,
      lengthComputable: (dur > 0)
    });
  }
}

function errorShow(error) {
  console.error(error);
}

function testerUpdateMorphData() {
  let s = '{';
  for( let mt of head.getMorphTargetNames() ) {
    const el = d3.select('#' + CSS.escape(mt));
    if ( !el.empty() ) {
      const v = testerGetFixedValue( mt, parseFloat(el.property("value")) );
      if ( v !== null ) {
        s += (s.length > 1 ? ',' : '') + ' ' + mt + ': [' + v + ']';
      }
    }
  }
  s += ' }';
  d3.select('#morphdata').property("value",s).dispatch('change');
}

function testerGetValue(mt,v) {
  if ( mt.startsWith('headRotate') || mt.startsWith('bodyRotate') || mt.startsWith('eyesRotate') ) {
    return ( v === null || v === undefined ) ? 0 : v;
  } else {
    return ( v === null || v === undefined ) ? -0.1 : v;
  }
}

function testerGetFixedValue(mt,v) {
  if ( mt.startsWith('headRotate') || mt.startsWith('bodyRotate') || mt.startsWith('eyesRotate') ) {
    return ( v === 0 ? null : v);
  } else {
    return ( v >= 0 ? v : null);
  }
}

function testerGetMin(mt) {
  if ( mt.startsWith('headRotate') || mt.startsWith('bodyRotate') ) {
    return -0.5;
  } else if ( mt.startsWith('eyesRotate') ) {
    return -1;
  } else {
    return -0.1;
  }
}

function testerGetMax(mt) {
  return (mt.startsWith('headRotate') || mt.startsWith('bodyRotate')) ? 0.5 : 1;
}

function testerGetStep(mt) {
  return ( mt.startsWith('headRotate') || mt.startsWith('bodyRotate') || mt.startsWith('eyesRotate') ) ? 0.05 : 0.1;
}

function testerGetLabel(mt,v) {
  if ( mt.startsWith('headRotate') || mt.startsWith('bodyRotate') || mt.startsWith('eyesRotate') ) {
    return (v ? v : '');
  } else {
    return ( v>=0 ? v : '');
  }
}


// Script
let scriptIsRunning = false;
let scriptBlocks = [];
let scriptIndex = 0;

function scriptStatus(msg=null) {
  const el = d3.select("#scriptstatus");
  if ( msg ) {
    el.text( msg );
  } else if ( scriptIsRunning ) {
    el.text( "ACTIVE" );
  } else {
    const size = scriptBlocks.length;
    if ( size === 0 ) {
      el.text( "" );
    } else if ( scriptIndex === 0 ) {
      el.text( "READY" );
    } else if ( scriptIndex >= size ) {
      el.text( "END" );
    } else {
      el.text( (scriptIndex + 1) + "/" + size );
    }
  }
}

function scriptInit() {
  const script = d3.select("#script").property("value");
  scriptBlocks = script
    .replaceAll('\n\n\n','\n\n').trim()
    .split('\n\n')
    .map( x => x.trim().split('\n')
    .map( y => y.trim() ).filter( y => y.length) )
    .filter( y => y.length );
  scriptIndex = 0;
  scriptStatus();
}

function scriptCommand(ev) {
  if ( ev.altKey ) {
    if ( scriptIsRunning ) {
      if ( ev.keyCode === 37 ) { // Arrow left
        scriptIsRunning = false;
      }
    } else {
      const size = scriptBlocks.length;
      const status = d3.select("#scriptstatus");
      if ( ev.keyCode === 38 ) { // Arrow up
        if ( scriptIndex > 0 ) scriptIndex--;
        scriptStatus();
      } else if ( ev.keyCode === 39 ) { // Arrow right
        if ( scriptIndex < scriptBlocks.length ) {
          scriptIsRunning = true;
          scriptRun(scriptIndex);
          scriptStatus();
        }
      } else if ( ev.keyCode === 40 ) { // Arrow down
        if ( scriptIndex < scriptBlocks.length ) scriptIndex++;
        scriptStatus();
      }
    }
  }
}

window.sleep = ms => new Promise(r => setTimeout(r, ms));
const AsyncFunction = async function () {}.constructor;
async function scriptRun() {
  let node = null;
  for( let i=0; i < scriptBlocks[scriptIndex].length; i++ ) {
    if ( !scriptIsRunning ) break;

    let x = scriptBlocks[scriptIndex][i];

    if ( x.charAt(0) === '#' ) {
      // Comment, ignore
    } else if ( x.charAt(x.length-1) === ';' ) {
      // Function
      try {
        const fn = new AsyncFunction( x );
        await fn();
      } catch( err ) {
        console.error(err);
      }
    } else {

      // First text
      if ( !node ) {
        node = addMessage(false);
      } else {
        addText( node, " " );
      }

      if ( cfg('voice-type') === 'eleven' ) {
        await new Promise(resolve => {
          elevenOnProcessed = resolve;
          elevenSpeak( x + " ", node );
          elevenSpeak( "" );
        });
        elevenOnProcessed = null;
      } else if ( cfg('voice-type') === 'microsoft' ) {
        await new Promise(resolve => {
          microsoftSpeak( x, node, resolve );
        });
      } else {
        await head.speakText( x, {
          lipsyncLang: cfg('voice-lipsync-lang'),
          ttsVoice: cfg('voice-google-id'),
          ttsRate: cfg('voice-google-rate'),
          ttsPitch: cfg('voice-google-pitch')
        }, addText.bind(null,node) );
      }

      // Wait for it
      await new Promise(resolve => {
        head.speakMarker(resolve);
      });

    }
  }

  // Close connection
  if ( node ) {
    if ( elevenSocket ) {
      elevenSpeak("",null);
    }
    microsoftSpeak(null);
    d3.selectAll('.blink').classed("blink",false);
  }

  scriptIndex++;
  scriptIsRunning = false;
  scriptStatus();
}





// Page ready
document.addEventListener('DOMContentLoaded', async function(e) {

  // Add supported UI languages
  const eLanguages = d3.select("#languages");
  for ( const k of Object.keys(i18n) ) {
    eLanguages.append("div")
      .classed("command", true)
      .classed("selected", k === 'fi' )
      .attr("data-item","theme-lang")
      .attr("data-type","option")
      .attr("data-theme-lang",k)
      .attr("data-i18n-text",k);
  }

  // Add avatar links
  const eAvatars = d3.select("#avatars");
  for ( const [i,k] of Object.entries(Object.keys(site.avatars)) ) {
    eAvatars.append("div")
      .classed("command", true)
      .classed("selected", parseInt(i) === 0 )
      .attr("data-item","avatar-name")
      .attr("data-type","option")
      .attr("data-avatar-name", k )
      .attr("data-i18n-site","avatars-"+k);
  }

  // Add Google voices
  const eGoogleVoices = d3.select("#googlevoices");
  for ( const [i,k] of Object.entries(Object.keys(site.googleVoices)) ) {
    let o = site.googleVoices[k];
    eGoogleVoices.append("div")
      .classed("command", true)
      .classed("selected", parseInt(i) === 0 )
      .attr("data-item","voice-google-id")
      .attr("data-type","option")
      .attr("data-voice-google-id",o.id)
      .attr("data-i18n-site","googleVoices-"+k);
  }

  // Add ElevenLabs voices
  const eElevenVoices = d3.select("#elevenvoices");
  for ( const [i,k] of Object.entries(Object.keys(site.elevenVoices)) ) {
    let o = site.elevenVoices[k];
    eElevenVoices.append("div")
      .classed("command", true)
      .classed("selected", parseInt(i) === 0 )
      .attr("data-item","voice-eleven-id")
      .attr("data-type","option")
      .attr("data-voice-eleven-id",o.id)
      .attr("data-i18n-site","elevenVoices-"+k);
  }

  // Add Microsoft voices
  const eMicrosoftVoices = d3.select("#microsoftvoices");
  for ( const [i,k] of Object.entries(Object.keys(site.microsoftVoices)) ) {
    let o = site.microsoftVoices[k];
    eMicrosoftVoices.append("div")
      .classed("command", true)
      .classed("selected", parseInt(i) === 0 )
      .attr("data-item","voice-microsoft-id")
      .attr("data-type","option")
      .attr("data-voice-microsoft-lang",o.lang)
      .attr("data-voice-microsoft-id",o.id)
      .attr("data-voice-microsoft-viseme", o.viseme )
      .attr("data-i18n-site","microsoftVoices-"+k);
  }

  // Add views
  const eViews = d3.select("#views");
  for ( const [k,o] of Object.entries(site.views) ) {
    eViews.append("div")
      .classed("command", true)
      .attr("data-item","view-image")
      .attr("data-type","option")
      .attr("data-image-type",o.type)
      .attr("data-view-image",o.url)
      .attr("data-i18n-site","views-"+k);
  }

  // Add poses
  const ePoses = d3.select("#poses");
  for ( const [k,o] of Object.entries(site.poses) ) {
    ePoses.append("div")
      .classed("command", true)
      .attr("data-pose",o.url)
      .attr("data-i18n-site","poses-"+k);
  }

  // Add gestures
  if ( site.gestures ) {
    const eGestures = d3.select("#gestures");
    for ( const [k,o] of Object.entries(site.gestures) ) {
      eGestures.append("div")
        .classed("command", true)
        .attr("data-gesture",o.name)
        .attr("data-i18n-site","gestures-"+k);
    }
  }

  // Add animations
  const eAnimations = d3.select("#animations");
  for ( const [k,o] of Object.entries(site.animations) ) {
    eAnimations.append("div")
      .classed("command", true)
      .attr("data-animation",o.url)
      .attr("data-i18n-site","animations-"+k);
  }

  // Add impulse responses
  const eImpulses = d3.select("#impulses");
  for ( const [k,o] of Object.entries(site.impulses) ) {
    eImpulses.append("div")
      .classed("command", true)
      .attr("data-item","voice-reverb")
      .attr("data-type","option")
      .attr("data-voice-reverb",o.url)
      .attr("data-i18n-site","impulses-"+k);
  }

  // Add music
  const eMusic = d3.select("#music");
  for ( const [k,o] of Object.entries(site.music) ) {
    eMusic.append("div")
      .classed("command", true)
      .attr("data-item","voice-background")
      .attr("data-type","option")
      .attr("data-voice-background",o.url)
      .attr("data-i18n-site","music-"+k);
  }

  // Translate
  i18nTranslate();

  // Create the talking head avatar
  const nodeAvatar = document.getElementById('avatar');
  head = new TalkingHead( nodeAvatar, {
    jwtGet: jwtGet,
    ttsEndpoint: googleTTSProxy,
    cameraZoomEnable: true,
    cameraPanEnable: true,
    cameraView: 'full',
    avatarMood: 'neutral',
    lipsyncModules: ["en", "fi", "lt"],
    // Stats display that can be used when testing performance
    statsNode: document.body,
    statsStyle: "position: fixed; bottom: 0px; left: 0px; cursor: pointer; opacity: 0.9; z-index: 10000;"
  });
  window.head = head;

  // Follow double clicks
  document.body.addEventListener('dblclick', function(e) {
    e = e || window.event;
    if ( !head.touchAt(e.clientX,e.clientY) ) {
      head.lookAt(e.clientX,e.clientY,500)
    }
  });

  // Media progress
  d3.select("#video").node().addEventListener("progress", progressMedia);

  // Auto resize textarea
  d3.selectAll("textarea").on("input.resize change.resize keyup.resize paste.resize", function(e) {
    let pos = this.parentElement.parentElement.scrollTop;
    this.style.height = '0px';
    this.style.height = this.scrollHeight+'px';
    this.parentElement.parentElement.scrollTop = pos;
  });

  // Reset moderation flag, score and word count
  d3.selectAll("textarea").on("input.moderate change.moderate paste.moderate", function(e) {
    delete this.dataset.flag;
    delete this.dataset.score;
    delete this.dataset.words;
  });

  // Send message
  d3.select("#input").on("keydown", async function(ev) {
    if ( ev.keyCode === 13 && !ev.shiftKey ) {
      ev.preventDefault();
      const e = d3.select("#input");
      let text = e.property("value");
      if ( head && text.length ) {

        if ( cfg('ai-model').startsWith("gpt") ) {
          const m = openaiBuildMessage();
          let flag = await openaiModerateMessage(m);

          const nodeInput = addMessage(true);
          nodeInput.dataset.input = text;
          addText(nodeInput,text);
          e.property("value","");

          if ( flag ) {
            console.info("Moderation flagged.");
            d3.select(nodeInput).classed("grayed", true );
            d3.select(nodeInput .select).classed("selected", true );
          } else {
            const nodeOutput = addMessage(false);
            openaiSendMessage(nodeOutput,m);
          }
        } else if ( cfg('ai-model').startsWith("gemini") ) {
          const m = geminiBuildMessage();

          const nodeInput = addMessage(true);
          nodeInput.dataset.input = text;
          addText(nodeInput,text);
          e.property("value","");

          const nodeOutput = addMessage(false);
          geminiSendMessage(nodeOutput,m);
        } else if ( cfg('ai-model').startsWith("llama") ) {
          const m = openaiBuildMessage();

          const nodeInput = addMessage(true);
          nodeInput.dataset.input = text;
          addText(nodeInput,text);
          e.property("value","");

          const nodeOutput = addMessage(false);
          llamaSendMessage(nodeOutput,m);
        } else if ( cfg('ai-model').startsWith("grok") ) {
          const m = openaiBuildMessage();

          const nodeInput = addMessage(true);
          nodeInput.dataset.input = text;
          addText(nodeInput,text);
          e.property("value","");

          const nodeOutput = addMessage(false);
          grokSendMessage(nodeOutput,m);
        }

      }
    }
  });

  // Change UI language
  d3.selectAll("[data-theme-lang]").on('click.command', function(ev) {
    const e = d3.select(this);
    d3.selectAll("[data-theme-lang]").classed('selected',false);
    e.classed('selected',true);
    const lang = e.attr("data-theme-lang");
    cfg('theme-lang',lang);
    i18nTranslate();
    d3.selectAll("[data-range]").dispatch("change");
  });

  // Speak test
  d3.select("#playtest").on("click", function(ev) {
    const e = d3.select("[data-voice-test]");
    let text = e.property("value");
    if ( head && text.length ) {
      if ( cfg('voice-type') === 'eleven' ) {
        elevenSpeak( text + " " );
        elevenSpeak( "" );
      } else if ( cfg('voice-type') === 'microsoft' ) {
        microsoftSpeak( text );
        microsoftSpeak( null );
      } else {
        const exclude = excludesProcess(text);
        head.speakText( text, {
          lipsyncLang: cfg('voice-lipsync-lang'),
          ttsVoice: cfg('voice-google-id'),
          ttsRate: cfg('voice-google-rate'),
          ttsPitch: cfg('voice-google-pitch')
        }, null, exclude.excludes );
      }
    }
  });

  // MP3 test file
  d3.select("#loadmp3-file").on("change", function(ev) {
    let file = ev.target.files[0];
    whisperLoadMP3(file);
    ev.target.value = '';
  });

  d3.select("#playmp3").on("click", function(ev) {
    if ( whisperAudio ) {
      head.speakAudio( whisperAudio, { lipsyncLang: whisperLipsyncLang } );
    }
  });

  // Repeat/mirror
  d3.selectAll("#pose-repeat,#animation-repeat,#gesture-repeat,#gesture-mirror").on("click", function(ev) {
    const e = d3.select(this);
    const sel = e.classed("selected");
    e.classed("selected", !sel );
  });

  d3.select("#pause").on("click", function(ev) {
    const e = d3.select(this);
    const sel = e.classed("selected");
    e.classed("selected", !sel );
    if ( !sel ) {
      head.stop();
    } else {
      head.start();
    }
  });

  d3.select("#slowdown").on("click", function(ev) {
    const e = d3.select(this);
    let k = 2 * head.getSlowdownRate();
    let t = i18nWord('Slow-motion') + ' x' + k;
    if ( k >= 16 ) {
      k = 1;
      t = i18nWord('Slow-motion');
    }
    e.classed("selected", (k > 1) ).text(t);
    head.setSlowdownRate( k );
  });

  d3.select("#autorotate").on("click", function(ev) {
    const e = d3.select(this);
    let k = head.getAutoRotateSpeed() + 10;
    let t = i18nWord('Panning') + ' ' + k;
    if ( k >= 60 ) {
      k = 0;
      t = i18nWord('Panning');
    }
    e.classed("selected", (k > 0) ).text(t);
    head.setAutoRotateSpeed( k );
  });

  // Avatar mood
  d3.selectAll("[data-mood]").on('click.command', function(ev) {
    const e = d3.select(this);
    head.setMood( e.attr('data-mood') );
  });

  // Avatar pose
  d3.selectAll("[data-pose]").on('click.command', async function(ev) {
    const e = d3.select(this);
    const sel = e.classed("selected");
    const repeat = d3.select("#pose-repeat").classed("selected");
    d3.selectAll("[data-pose]").classed("selected",false);
    if ( sel ) {
      head.stopPose();
    } else {
      let pose = e.attr('data-pose');
      if ( pose !== 'FILE' ) {
        d3.selectAll("[data-pose='" + pose + "']").classed("selected",repeat);
        head.playPose( pose, progressUpdate, (repeat ? 600 : 5) );
      }
    }
  });

  // Avatar gesture
  d3.selectAll("[data-gesture]").on('click.command', async function(ev) {
    const e = d3.select(this);
    const sel = e.classed("selected");
    const repeat = d3.select("#gesture-repeat").classed("selected");
    const mirror = d3.select("#gesture-mirror").classed("selected");
    d3.selectAll("[data-gesture]").classed("selected",false);
    if ( sel ) {
      head.stopGesture();
    } else {
      let g = e.attr('data-gesture');
      d3.selectAll("[data-gesture='" + g + "']").classed("selected",repeat);
      head.playGesture( g, (repeat ? 600 : 5), mirror );
    }
  });

  // Open pose file
  d3.select("#pose-file").on('change', function(ev) {
    let file = ev.target.files[0];
    var reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload =  (readerEvent) => {
      let content = readerEvent.target.result;
      const repeat = d3.select("#pose-repeat").classed("selected");
      d3.selectAll("[data-pose='FILE']").classed("selected",repeat);
      head.playPose( content, progressUpdate, (repeat ? 600 : 5) );
    }
    ev.target.value = '';
  });

  d3.selectAll("[data-animation]").on('click.command', async function(ev) {
    const e = d3.select(this);
    const sel = e.classed("selected");
    const repeat = d3.select("#animation-repeat").classed("selected");
    d3.selectAll("[data-animation]").classed("selected",false);
    if ( sel ) {
      head.stopAnimation();
    } else {
      let animation = e.attr('data-animation');
      if ( animation !== 'FILE' ) {
        d3.selectAll("[data-animation='" + animation + "']").classed("selected",repeat);
        head.playAnimation( animation, progressUpdate, (repeat ? 300 : 7) );
      }
    }
  });

  // Open animation file
  d3.select("#animation-file").on('change', function(ev) {
    let file = ev.target.files[0];
    var reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = (ev2) => {
      let content = ev2.target.result;
      const repeat = d3.select("#animation-repeat").classed("selected");
      d3.selectAll("[data-animation='FILE']").classed("selected",repeat);
      head.playAnimation( content, progressUpdate, (repeat ? 300 : 7) );
    }
    ev.target.value = '';
  });

  // Save configuration changes
  d3.selectAll("[data-item]").on('click.config input.config change.config keyup.config', function(ev) {
    const e = d3.select(this);
    const item = e.attr("data-item");
    const type = e.attr("data-type");
    const range = e.attr("data-range");
    let value;
    if ( type === 'boolean' ) {
      value = !e.classed( "selected" );
      e.classed( "selected", value );
    } else if ( type === "option" ) {
      value = e.attr("data-"+item);
    } else if ( type === "value" ) {
      if ( range !== null ) {
        value = parseFloat( e.property("value") );
      } else {
        value = e.property("value");
      }
    }
    if ( !loadingConfig && value !== undefined && cfg( item ) !== value ) {
      cfg( item, value );
      saveConfig();
    }
  });

  // Change session
  d3.selectAll("[data-session]").on('click.command', entrySelect );
  d3.selectAll("[data-entry-move]").on('click.command', entryMove );

  d3.select("#selectall").on("click", function(ev) {
    const e = d3.select(this);
    const mode = !e.classed("selected");
    e.classed("selected", mode);

    d3.select(".session.selected").selectAll(".select").nodes().forEach( (n) => {
      const x = d3.select(n);
      if ( x.classed("selected") !== mode ) {
        x.dispatch("click");
      }
    });
  });

  // Reset range
  d3.selectAll("[data-range-reset]").on('click.command', function(ev) {
    const e = d3.select(this);
    const target = e.attr("data-target");
    const value = parseFloat(e.attr("data-range-reset"));
    d3.select("[data-"+target+"]").property("value",value).dispatch("change");
  });

  // Show value labels
  d3.selectAll("[data-range]").on('input.label change.label keyup.label', function(ev) {
    const e = d3.select(this);
    const n = e.node();
    const type = e.attr("data-range");
    let v = '';
    if ( type === 'float' ) {
      v = Math.round(100 * n.value) / 100;
    } else if ( type === 'second' ) {
      v = Math.round(100 * n.value) / 100 + ' s';
    } else if ( type === 'percentage' ) {
      v = Math.round(100 * n.value) + '%';
    } else if ( type === 'px' ) {
      v = n.value + ' px';
    } else if ( type === 'meter' ) {
      v = n.value + ' m';
    } else if ( type === 'radian' ) {
      v = n.value + ' rad';
    } else if ( type === 'word' ) {
      v = n.value + ' ' + i18nWord('words');
    } else if ( type === 'dialog' ) {
      v = n.value + ' ' + i18nWord('dialogs');
    }
    n.nextElementSibling.textContent = v;
  });

  d3.selectAll("[data-item='name']").on('input.command change.command keyup.command', function(ev) {
    const e = d3.select(this);
    const name = e.property("value");
    d3.select("#entry-"+CFG.session).select("div").text( name );
    d3.select("#name").text( name );
  });

  // Show/hide pages
  d3.selectAll("[data-show]").on('click.command', function(ev) {
    const e = d3.select(this);
    const sel = e.classed("selected");
    const show = e.attr("data-show");
    const parts = show.split("-");

    d3.selectAll("[data-show*='" + parts[0] + "-']").classed("selected", false);
    d3.selectAll("[id*='" + parts[0] + "-']").classed("hidden", true);
    if ( !sel ) {
      e.classed("selected",true);
      d3.select('#'+show)
        .classed("hidden", false)
        .selectAll("textarea").dispatch("keyup");
      if ( parts[0] === 'right' ) {
        d3.select("#right-sessions").classed("hidden", true);
      }
    } else {
      if ( parts[0] === 'right' ) {
        d3.select("#right-sessions").classed("hidden", false);
      }
    }
  });

  d3.selectAll("[data-theme-ratio]").on('click.command', function(ev) {
    const e = d3.select(this);
    d3.selectAll("[data-theme-ratio]").classed('selected',false);
    e.classed('selected',true);
    const main = d3.select("#main");
    d3.selectAll("[data-theme-ratio]").nodes().forEach( x => {
      main.classed("ratio-" + x.dataset.themeRatio, false);
    });
    let ratio = 'ratio-' + d3.select("[data-theme-ratio].selected").attr('data-theme-ratio');
    main.classed(ratio, true);
  });

  d3.selectAll("[data-theme-layout]").on('click.command', function(ev) {
    const e = d3.select(this);
    d3.selectAll("[data-theme-layout]").classed('selected',false);
    e.classed('selected',true);
    const main = d3.select("#main");
    d3.selectAll("[data-theme-layout]").nodes().forEach( x => {
      main.classed("layout-" + x.dataset.themeLayout, false);
    });
    let layout = 'layout-' + d3.select("[data-theme-layout].selected").attr('data-theme-layout');
    main.classed(layout, true);
  });

  d3.selectAll("[data-theme-brightness]").on('click.command', function(ev) {
    const e = d3.select(this);
    d3.selectAll("[data-theme-brightness]").classed('selected',false);
    e.classed('selected',true);
    const body = d3.select("body");
    d3.selectAll("[data-theme-brightness]").nodes().forEach( x => {
      body.classed("theme-" + x.dataset.themeBrightness, false);
    });
    let theme = 'theme-' + d3.select("[data-theme-brightness].selected").attr('data-theme-brightness');
    body.classed(theme, true);
  });

  d3.selectAll("[data-avatar-name]").on('click.command', async function(ev) {
    const e = d3.select(this);
    d3.selectAll("[data-avatar-name]").classed('selected',false);
    let avatar = e.attr('data-avatar-name');
    d3.selectAll("[data-avatar-name='" + avatar + "']").classed("selected",true);
    if ( avatar === 'FILE' ) {
      // Do nothing
    } else if ( avatar === 'URL' ) {
      let url = cfg('avatar-url');
      d3.selectAll("[data-pose],[data-animation],#pause").classed("selected",false);
      const o = {
        url: url,
        body: cfg('avatar-body')
      };
      if ( url !== head.avatar?.url ) {
        try {
          await head.showAvatar( o, progressUpdate );
          headLoaded();
          d3.select("[data-camera-frame].selected").dispatch('click');
        } catch(error) {
          errorShow(error);
        }
      }
    } else {
      const name = e.attr('data-avatar-name');
      d3.selectAll("[data-pose],[data-animation],#pause").classed("selected",false);
      if ( site.avatars[name].url !== head.avatar?.url ) {
        try {
          await head.showAvatar( site.avatars[name], progressUpdate );
          headLoaded();
          d3.select("[data-camera-frame].selected").dispatch('click');
        } catch(error) {
          errorShow(error);
        }
      }
    }
  });

  // Open avatar file
  d3.select("#avatar-name-file").on('change', async function(ev) {
    let file = ev.target.files[0];
    var reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = async (ev2) => {
      d3.selectAll("[data-pose],[data-animation],#pause").classed("selected",false);
      const o = {
        url: ev2.target.result,
        body: cfg('avatar-body')
      };
      try {
        await head.showAvatar( o, progressUpdate );
        headLoaded();
        d3.select("[data-camera-frame].selected").dispatch('click');
      } catch(error) {
        errorShow(error);
      }
    }
    ev.target.value = '';
  });

  d3.selectAll("[data-avatar-brightness],[data-avatar-contrast],[data-avatar-saturate]").on('input.command change.command keyup.command', function(ev) {
    const e = d3.select(this);
    let filters = [];
    d3.selectAll("[data-avatar-brightness],[data-avatar-contrast],[data-avatar-saturate]").nodes().forEach( node => {
      filters.push( (node.dataset.avatarBrightness || node.dataset.avatarContrast || node.dataset.avatarSaturate) + '(' + node.value + ')' );
    });
    d3.select("#avatar").style("filter", filters.join(' ') );
  });

  d3.selectAll("[data-avatar-body]").on('click.command', function(ev) {
    const e = d3.select(this);
    d3.selectAll("[data-avatar-body]").classed('selected',false);
    e.classed('selected',true);
  });

  d3.selectAll("[data-view-image]").on('click.command', function(ev) {
    const e = d3.select(this);
    d3.selectAll("[data-view-image]").classed('selected',false);
    let view = e.attr('data-view-image');
    d3.selectAll("[data-view-image='" + view + "']").classed("selected",true);
    if ( view === 'NONE' ) {
      CFG.sessions[CFG.session].view.image = "NONE";
      d3.select("#main")
        .classed("presence-video",false)
        .classed("presence-vr", true);
      d3.select("#view-video").attr("src","");
      d3.select("#video").node().load();
      d3.select("#view").style("background-image","none" );
    } else if ( view === 'FILE' ) {
      // Do nothing
    } else if ( view === 'URL' ) {
      CFG.sessions[CFG.session].view.image = "URL";
      d3.select("#main")
        .classed("presence-video", true)
        .classed("presence-vr", false);
      d3.select("#view-video").attr("src","");
      d3.select("#video").node().load();
      const image = cfg('view-url');
      d3.select("#view").style("background-image","url(" + image + ")" );
    } else {
      CFG.sessions[CFG.session].view.image = view;
      d3.select("#main")
        .classed("presence-video", true)
        .classed("presence-vr", false);
      const image = e.attr('data-view-image');
      const type = e.attr('data-image-type');
      if ( type.startsWith('video/') ) {
        d3.select("#view-video")
          .attr("src", image )
          .attr("type", type );
        d3.select("#video").node().load();
        d3.select("#view").style("background-image","none" );
      } else if ( type.startsWith('image/') ) {
        d3.select("#view-video").attr("src","");
        d3.select("#video").node().load();
        d3.select("#view").style("background-image","url(" + image + ")" );
      }
    }
  });

  // Open view image file
  d3.select("#view-image-file").on('change', function(ev) {
    let file = ev.target.files[0];
    var reader = new FileReader();
    if ( file.type.startsWith('image/') ) {
      d3.select("#main")
        .classed("presence-video", true)
        .classed("presence-vr", false);
      reader.readAsDataURL(file);
      reader.onload = (ev2) => {
        d3.select("#view-video").attr("src","");
        d3.select("#video").node().load();
        d3.select("#view").style("background-image","url(" + ev2.target.result + ")" );
      }
    } else if ( file.type.startsWith('video/') ) {
      d3.select("#main")
        .classed("presence-video", true)
        .classed("presence-vr", false);
      reader.readAsDataURL(file);
      reader.onload = (ev2) => {
        let content = ev2.target.result;
        d3.select("#view-video").attr("src",content);
        d3.select("#video").node().load();
      }
    }
    ev.target.value = '';
  });

  d3.select("[data-pose-movement]").on('input.command change.command keyup.command', function(ev) {
    let factor = parseFloat( d3.select("[data-pose-movement]").property("value") );
    head.opt.modelMovementFactor = factor;
    head.setPoseFromTemplate( head.poseCurrentTemplate );
  });

  d3.selectAll("[data-camera-frame]").on('click.command', function(ev) {
    const e = d3.select(this);
    d3.selectAll("[data-camera-frame]").classed('selected',false);
    const camera = e.attr('data-camera-frame');
    d3.selectAll("[data-camera-frame='" + camera + "']").classed("selected",true);
    const opt = {
      cameraX: parseFloat( cfg("camera-x") || 0 ),
      cameraY: parseFloat( cfg("camera-y") || 0 ),
      cameraDistance: parseFloat( cfg("camera-d") || 0 ),
      cameraRotateX: parseFloat( cfg("camera-rotx") || 0 ),
      cameraRotateY: parseFloat( cfg("camera-roty") || 0 )
    };
    head.setView( camera, opt );
  });

  d3.selectAll("[data-camera-x],[data-camera-y],[data-camera-d],[data-camera-rotx],[data-camera-roty]").on('input.command change.command keyup.command', function(ev) {
    d3.select("[data-camera-frame].selected").dispatch('click');
  });

  d3.select("[data-camera-fps]").on('input.command change.command keyup.command', function(ev) {
    let fps = parseFloat( d3.select("[data-camera-fps]").property("value") );
    head.opt.modelFPS = fps;
    head.animFrameDur = 1000 / fps;
  });

  function setLightingData() {
    let o = {
      lightAmbientColor: d3.select("[data-light-ambient-color]").property("value"),
      lightAmbientIntensity: parseFloat( d3.select("[data-light-ambient-intensity]").property("value") ),
      lightDirectColor: d3.select("[data-light-direct-color]").property("value"),
      lightDirectIntensity: parseFloat( d3.select("[data-light-direct-intensity]").property("value") ),
      lightDirectPhi: parseFloat( d3.select("[data-light-direct-phi]").property("value") ),
      lightDirectTheta: parseFloat( d3.select("[data-light-direct-theta]").property("value") ),
      lightSpotColor: d3.select("[data-light-spot-color]").property("value"),
      lightSpotIntensity: parseFloat( d3.select("[data-light-spot-intensity]").property("value") ),
      lightSpotPhi: parseFloat( d3.select("[data-light-spot-phi]").property("value") ),
      lightSpotTheta: parseFloat( d3.select("[data-light-spot-theta]").property("value") ),
      lightSpotDispersion: parseFloat( d3.select("[data-light-spot-dispersion]").property("value") )
    };
    d3.select('#lightingdata').property("value", JSON.stringify( o ) );
  }

  d3.selectAll("[data-light-ambient-color],[data-light-ambient-intensity]").on('input.command change.command keyup.command', function(ev) {
    const e = d3.select(this);
    let o = {
      lightAmbientColor: d3.select("[data-light-ambient-color]").property("value"),
      lightAmbientIntensity: parseFloat( d3.select("[data-light-ambient-intensity]").property("value") )
    };
    head.setLighting(o);
    setLightingData();
  });

  d3.selectAll("[data-light-direct-color],[data-light-direct-intensity],[data-light-direct-phi],[data-light-direct-theta]").on('input.command change.command keyup.command', function(ev) {
    const e = d3.select(this);
    let o = {
      lightDirectColor: d3.select("[data-light-direct-color]").property("value"),
      lightDirectIntensity: parseFloat( d3.select("[data-light-direct-intensity]").property("value") ),
      lightDirectPhi: parseFloat( d3.select("[data-light-direct-phi]").property("value") ),
      lightDirectTheta: parseFloat( d3.select("[data-light-direct-theta]").property("value") )
    };
    head.setLighting(o);
    setLightingData();
  });

  d3.selectAll("[data-light-spot-color],[data-light-spot-intensity],[data-light-spot-phi],[data-light-spot-theta],[data-light-spot-dispersion]").on('input.command change.command keyup.command', function(ev) {
    const e = d3.select(this);
    let o = {
      lightSpotColor: d3.select("[data-light-spot-color]").property("value"),
      lightSpotIntensity: parseFloat( d3.select("[data-light-spot-intensity]").property("value") ),
      lightSpotPhi: parseFloat( d3.select("[data-light-spot-phi]").property("value") ),
      lightSpotTheta: parseFloat( d3.select("[data-light-spot-theta]").property("value") ),
      lightSpotDispersion: parseFloat( d3.select("[data-light-spot-dispersion]").property("value") ),
    };
    head.setLighting(o);
    setLightingData();
  });

  d3.selectAll("[data-view-brightness],[data-view-contrast],[data-view-saturate],[data-view-blur]").on('input.command change.command keyup.command', function(ev) {
    const e = d3.select(this);
    let filters = [];
    d3.selectAll("[data-view-brightness],[data-view-contrast],[data-view-saturate],[data-view-blur]").nodes().forEach( node => {
      filters.push( (node.dataset.viewBrightness || node.dataset.viewContrast || node.dataset.viewSaturate || node.dataset.viewBlur) + '(' + node.value + (node.dataset.viewBlur ? 'px' :'') + ')' );
    });
    d3.select("#view").style("filter", filters.join(' ') );
  });

  d3.selectAll("[data-voice-type]").on('click.command', function(ev) {
    const e = d3.select(this);
    d3.selectAll("[data-voice-type]").classed('selected',false);
    e.classed('selected',true);
    d3.select("#voice-google").style("display", (e.attr("data-voice-type") === 'google') ? "flex" : "none" );
    d3.select("#voice-eleven").style("display", (e.attr("data-voice-type") === 'eleven') ? "flex" : "none" );
    d3.select("#voice-microsoft").style("display", (e.attr("data-voice-type") === 'microsoft') ? "flex" : "none" );
    d3.select("#lipsync").style("display", (e.attr("data-voice-type") !== 'microsoft') ? "flex" : "none" );
    d3.select("#excludes").style("display", (e.attr("data-voice-type") === 'google') ? "flex" : "none" );
  });

  d3.selectAll("[data-voice-google-id]").on('click.command', function(ev) {
    const e = d3.select(this);
    d3.selectAll("[data-voice-google-id]").classed('selected',false);
    e.classed('selected',true);
  });

  d3.selectAll("[data-voice-eleven-id]").on('click.command', function(ev) {
    const e = d3.select(this);
    d3.selectAll("[data-voice-eleven-id]").classed('selected',false);
    e.classed('selected',true);
  });

  d3.selectAll("[data-voice-microsoft-id]").on('click.command', function(ev) {
    const e = d3.select(this);
    d3.selectAll("[data-voice-microsoft-id]").classed('selected',false);
    e.classed('selected',true);
  });

  d3.selectAll("[data-voice-lipsync-lang]").on('click.command', function(ev) {
    const e = d3.select(this);
    d3.selectAll("[data-voice-lipsync-lang]").classed('selected',false);
    e.classed('selected',true);
    d3.select('#visemeword').dispatch('change');
  });

  d3.select("[data-voice-mixerbg]").on('input.command change.command keyup.command', function(ev) {
    let gain = parseFloat( d3.select("[data-voice-mixerbg]").property("value") );
    head.setMixerGain( null, gain );
  });

  d3.select("[data-voice-mixerspeech]").on('input.command change.command keyup.command', function(ev) {
    let gain = parseFloat( d3.select("[data-voice-mixerspeech]").property("value") );
    head.setMixerGain( gain, null );
  });

  d3.selectAll("[data-voice-reverb]").on('click.command', function(ev) {
    const e = d3.select(this);
    d3.selectAll("[data-voice-reverb]").classed('selected',false);
    e.classed('selected',true);
    let reverb = e.attr('data-voice-reverb');
    if ( reverb === 'NONE' ) {
      head.setReverb(null);
    } else {
      head.setReverb(reverb);
    }
  });

  d3.selectAll("[data-voice-background]").on('click.command', async function(ev) {
    const e = d3.select(this);
    d3.selectAll("[data-voice-background]").classed("selected",false);
    let background = e.attr('data-voice-background');
    d3.selectAll("[data-voice-background='" + background + "']").classed("selected",true);
    if ( background === 'NONE' ) {
      head.stopBackgroundAudio();
    } else if ( background === 'FILE' ) {
      // Do nothing
    } else {
      head.playBackgroundAudio(background);
    }
  });

  // Whisper
  d3.selectAll("[data-whisper-type]").on('click.command', function(ev) {
    const e = d3.select(this);
    d3.selectAll("[data-whisper-type]").classed('selected',false);
    e.classed('selected',true);
  });

  // Dynamic bones
  d3.select("[data-dynamicbones-sensitivity]").on('input.command change.command keyup.command', function(ev) {
    let factor = parseFloat( d3.select("[data-dynamicbones-sensitivity]").property("value") );
    head.dynamicbones.setOptionValue("sensitivityFactor",factor);
  });

  d3.select("[data-dynamicbones-movement]").on('input.command change.command keyup.command', function(ev) {
    let factor = parseFloat( d3.select("[data-dynamicbones-movement]").property("value") );
    head.dynamicbones.setOptionValue("movementFactor",factor);
  });

  // Open voice background file
  d3.select("#voice-background-file").on('change', function(ev) {
    let file = ev.target.files[0];
    var reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = (ev2) => {
      let content = ev2.target.result;
      head.playBackgroundAudio(content);
    }
    ev.target.value = '';
  });

  d3.selectAll("[data-ai-model]").on('click.command', function(ev) {
    const e = d3.select(this);
    d3.selectAll("[data-ai-model]").classed('selected',false);
    e.classed('selected',true);
    d3.select("#ai-openai").style("display", (e.attr("data-ai-model").startsWith('gpt') ) ? "flex" : "none" );
    d3.select("#ai-gemini").style("display", (e.attr("data-ai-model").startsWith('gemini') ) ? "flex" : "none" );
    d3.select("#ai-grok").style("display", (e.attr("data-ai-model").startsWith('grok') ) ? "flex" : "none" );
    d3.select("#ai-llama").style("display", (e.attr("data-ai-model").startsWith('llama') ) ? "flex" : "none" );
  });

  d3.select("#session-duplicate").on('click', function(ev) {
    let id = CFG.sessions.length;
    let clone = JSON.parse( JSON.stringify(cfg()) );
    clone.name = 'Nimetön';
    CFG.sessions.push(clone);
    saveConfig();
    loadConfig(id);
  });

  d3.select("#session-delete").on('click', function(ev) {
    if ( CFG.sessions.length > 1 ) {
      let id = CFG.session;
      CFG.sessions.splice(id,1);
      if ( id > 0 ) id--;
      saveConfig();
      loadConfig(id);
    }
  });

  d3.select("#delete").on("click", function(ev) {
    d3.select("#selectall").classed("selected",false);
    d3.select(".session.selected").selectAll(".select.selected").nodes().forEach( (n) => {
      d3.select(n.parentElement.parentElement).remove();
    });
  });

  d3.select("#flag").on("click", async function(ev) {
    let msgs = openaiBuildMessage();
    let flag = await openaiModerateMessage(msgs);
  });

  d3.select('#copy').on('click', function(ev) {
    const session = d3.select(".session.selected");
    const ms = [];

    [ 'ai-openai-system', 'ai-openai-user1', 'ai-openai-ai1',
      'ai-openai-user2', 'ai-openai-ai2' ].forEach( x => {
      let p = cfg(x);
      if ( p && p.length ) ms.push(p);
    });

    session.selectAll(".message").nodes().forEach( (d) => {
      let e = d3.select(d);
      let md = e.attr("data-input") || e.attr("data-output");
      ms.push( md );
    } );

    const textarea = document.createElement('textarea');
    textarea.value = ms.join("\n\n");
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand('copy');
    document.body.removeChild(textarea);
  });

  d3.select(window).on('resize.updatesvg', function(ev) {
    d3.selectAll("textarea").dispatch("keyup");
  });

  d3.selectAll("#json").on("blur", function(ev) {
    let e = d3.select(this);
    const json = e.property("value");
    try {
      const c = JSON.parse( json );
      CFG.sessions[CFG.session] = c;
      saveConfig();
      loadConfig();
      i18nTranslate();
    } catch(error) {
      console.error(error);
    }
  });

  // Motion (experimental)
  d3.selectAll("#motion").on("click", function(ev) {
    const e = d3.select(this);
    const sel = e.classed("selected");
    e.classed("selected", !sel );
  });

  // Record
  d3.select('#record').on('click', async function(ev) {
    const x = d3.select(this);
    const mode = !x.classed("selected");
    x.classed("selected",mode);
    // recordingPlaySound();
    if ( mode ) {
      recordingRecord();
    } else {
      if ( recordingMediaRecorder ) {
        if ( recordingMediaRecorder.state === 'recording' ) {
          recordingIgnoreData = true;
          recordingMediaRecorder.stop();
        }
        recordingMediaRecorder.stream.getTracks().forEach( track => track.stop() );
        recordingMediaRecorder = null;
      }
      head.stopListening();
    }
  });

  // Viseme tester
  d3.select('#visemeword').on('input change keyup paste', function(ev) {
    const e = d3.select(this);
    const word = e.property("value");
    if ( word ) {
      try {
        const preprocessed = head.lipsyncPreProcessText( word, cfg('voice-lipsync-lang')  );
        const visemes = head.lipsyncWordsToVisemes( preprocessed, cfg('voice-lipsync-lang') );
        d3.select('#visemedata').property("value", JSON.stringify( visemes ) ).dispatch("change");
      } catch(error) {
        d3.select('#visemedata').property("value", error ).dispatch("change");
      }
    } else {
      d3.select('#visemedata').property("value", "" ).dispatch("change");
    }
  });

  // Script
  d3.select("#script").on('input change keyup paste', scriptInit);
  d3.select("body").on('keydown', scriptCommand);

  // Pause animation when not visible
  document.addEventListener("visibilitychange", async function (ev) {
    if (document.visibilityState === "visible") {
      if ( !d3.select("#pause").classed("selected") ) {
        head.start();
      }
    } else {
      head.stop();
    }
  });

  // API keys
  d3.select("#apikey-gtts").on('input change keyup paste', function (ev) {
    const e = d3.select(this);
    const apikey = e.property("value");

    // Change the API key
    if ( apikey ) {
      head.opt.ttsEndpoint = googleTTSEndpoint;
      head.opt.ttsApikey = apikey;
      head.opt.jwtGet = null;
    } else {
      head.opt.ttsEndpoint = googleTTSProxy;
      head.opt.ttsApikey = null;
      head.opt.jwtGet = jwtGet;
    }
  });

  d3.select("#apikey-microsoft").on('input change keyup paste', function (ev) {
    microsoftSpeak(null); // Closes the current connection, if any
  });

  try {

    // Get token
    jwt = await jwtGet();

    // Show last avatar
    let o = {};
    let name = cfg('avatar-name') || Object.values(site.avatars)[0].name;
    if ( site.avatars.hasOwnProperty(name) ) {
      o = site.avatars[name];
    } else if ( name === 'URL' ) {
      o.url = cfg('avatar-url');
      o.body = cfg('avatar-body');
    } else {
      o =  Object.values(site.avatars)[0];
    }
    await head.showAvatar( o, progressUpdate);
    headLoaded(true);
  } catch (error) {
    errorShow(error);

    // Backup plan: show the first avatar in site config
    await head.showAvatar( Object.values(site.avatars)[0], progressUpdate);
    headLoaded(true);
  }

});

</script>
</head>
<body class="theme-dark">

  <div id="main" class="ratio-wide layout-land presence-video">

    <div id="left" class="noselect nodrag">

      <div id="view">
        <video id="video" autoplay loop muted playsinline>
          <source id="view-video" src="" type="video/mp4">
        </video>
      </div>

      <div id="avatar"></div>

      <div class="border starttransparent"></div>

      <div id="loading">
        <div id="loading-back"></div>
        <div id="loading-top"></div>
        <div id="loading-value"></div>
      </div>

    </div>


    <div id="right">

      <div class="pages">

        <div class="row noselect nodrag">

          <div class="command starttransparent" data-i18n-title="Session" data-show="right-session">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path d="M2 6C2 5.44772 2.44772 5 3 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H3C2.44772 7 2 6.55228 2 6Z" fill="currentColor" />
              <path d="M2 12.0322C2 11.4799 2.44772 11.0322 3 11.0322H21C21.5523 11.0322 22 11.4799 22 12.0322C22 12.5845 21.5523 13.0322 21 13.0322H3C2.44772 13.0322 2 12.5845 2 12.0322Z" fill="currentColor" />
              <path d="M3 17.0645C2.44772 17.0645 2 17.5122 2 18.0645C2 18.6167 2.44772 19.0645 3 19.0645H21C21.5523 19.0645 22 18.6167 22 18.0645C22 17.5122 21.5523 17.0645 21 17.0645H3Z" fill="currentColor" />
            </svg>
          </div>

          <div id="name" class="text starttransparent">
            Nimet&ouml;n
          </div>

          <div class="filler"></div>

          <div class="command starttransparent" data-i18n-title="Manuscript" data-show="right-ai">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path d="M7 18H17V16H7V18Z" fill="currentColor" />
              <path d="M17 14H7V12H17V14Z" fill="currentColor" />
              <path d="M7 10H11V8H7V10Z" fill="currentColor" />
              <path fill-rule="evenodd" clip-rule="evenodd" d="M6 2C4.34315 2 3 3.34315 3 5V19C3 20.6569 4.34315 22 6 22H18C19.6569 22 21 20.6569 21 19V9C21 5.13401 17.866 2 14 2H6ZM6 4H13V9H19V19C19 19.5523 18.5523 20 18 20H6C5.44772 20 5 19.5523 5 19V5C5 4.44772 5.44772 4 6 4ZM15 4.10002C16.6113 4.4271 17.9413 5.52906 18.584 7H15V4.10002Z" fill="currentColor" />
            </svg>
          </div>

        </div>

        <div id="right-ai" class="page noselect nodrag hidden">

          <div class="vbar"></div>

          <div class="row">
            <div class="text label" data-i18n-text="AI"></div>
            <div class="column">
              <div class="rowWrap">
                <div class="command selected" data-item="ai-model" data-type="option" data-ai-model="gpt-4.1-mini">GPT-4.1-mini</div>
                <div class="command" data-item="ai-model" data-type="option" data-ai-model="gpt-4.1">GPT-4.1</div>
                <div class="command" data-item="ai-model" data-type="option" data-ai-model="grok-3">Grok-3</div>
                <div class="command" data-item="ai-model" data-type="option" data-ai-model="gemini-1.5-pro">Gemini-1.5-pro</div>
                <div class="command" data-item="ai-model" data-type="option" data-ai-model="llama">Llama</div>
              </div>
            </div>
          </div>

          <div class="vbar"></div>

          <div id="ai-openai" class="column">
            <div class="row">
              <div class="text label" data-i18n-text="System"></div>
              <textarea data-i18n-placeholder="ai-system" rows="1" autocapitalize="sentences" data-item="ai-openai-system" data-type="value" data-ai-openai-system=""></textarea>
            </div>
            <div class="row">
              <div class="text label" data-i18n-text="Example1"></div>
              <textarea data-i18n-placeholder="ai-user1" rows="1" autocapitalize="sentences" data-item="ai-openai-user1" data-type="value" data-ai-openai-user1=""></textarea>
            </div>
            <div class="row">
              <div class="text label"></div>
              <textarea data-i18n-placeholder="ai-ai1" rows="1" autocapitalize="sentences" data-item="ai-openai-ai1" data-type="value" data-ai-openai-ai1=""></textarea>
            </div>
            <div class="row">
              <div class="text label" data-i18n-text="Example2"></div>
              <textarea data-i18n-placeholder="ai-user2" rows="1" autocapitalize="sentences" data-item="ai-openai-user2" data-type="value" data-ai-openai-user2=""></textarea>
            </div>
            <div class="row">
              <div class="text label"></div>
              <textarea data-i18n-placeholder="ai-ai2" rows="1" autocapitalize="sentences" data-item="ai-openai-ai2" data-type="value" data-ai-openai-ai2=""></textarea>
            </div>

            <div class="vbar"></div>

            <div class="row">
              <div class="text label" data-i18n-text="Adjust"></div>
              <div class="column">
                <div class="row">
                  <div class="command" data-target="ai-openai-temperature" data-range-reset="1.0">
                    <svg viewBox="0 0 1024 1024" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M336 972.8c-60.8-128-28.8-201.6 19.2-268.8 51.2-76.8 64-150.4 64-150.4s41.6 51.2 25.6 134.4c70.4-80 83.2-208 73.6-256 160 112 230.4 358.4 137.6 537.6 492.8-281.6 121.6-700.8 57.6-745.6 22.4 48 25.6 128-19.2 166.4-73.6-281.6-256-336-256-336 22.4 144-76.8 300.8-172.8 419.2-3.2-57.6-6.4-96-38.4-153.6-6.4 105.6-86.4 188.8-108.8 294.4C89.6 758.4 140.8 860.8 336 972.8L336 972.8z"  fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="0" max="2" step="0.1" value="1.0" data-range="float" data-item="ai-openai-temperature" data-type="value" data-ai-openai-temperature="">
                  <div class="text">1.0</div>
                </div>
                <div class="row">
                  <div class="command" data-target="ai-openai-presence" data-range-reset="0.0">
                    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M9.00967 5.12761H11.0097C12.1142 5.12761 13.468 5.89682 14.0335 6.8457L16.5089 11H21.0097C21.562 11 22.0097 11.4477 22.0097 12C22.0097 12.5523 21.562 13 21.0097 13H16.4138L13.9383 17.1543C13.3729 18.1032 12.0191 18.8724 10.9145 18.8724H8.91454L12.4138 13H5.42485L3.99036 15.4529H1.99036L4.00967 12L4.00967 11.967L2.00967 8.54712H4.00967L5.44417 11H12.5089L9.00967 5.12761Z" fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="-1" max="2" step="0.1" value="0.0" data-range="float" data-item="ai-openai-presence" data-type="value" data-ai-openai-presence="">
                  <div class="text">0.0</div>
                </div>
                <div class="row">
                  <div class="command" data-target="ai-openai-frequency" data-range-reset="0.0">
                    <svg viewBox="-2 -2 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path fill-rule="evenodd" clip-rule="evenodd" d="M21.2635 2.29289C20.873 1.90237 20.2398 1.90237 19.8493 2.29289L18.9769 3.16525C17.8618 2.63254 16.4857 2.82801 15.5621 3.75165L4.95549 14.3582L10.6123 20.0151L21.2189 9.4085C22.1426 8.48486 22.338 7.1088 21.8053 5.99367L22.6777 5.12132C23.0682 4.7308 23.0682 4.09763 22.6777 3.70711L21.2635 2.29289ZM16.9955 10.8035L10.6123 17.1867L7.78392 14.3582L14.1671 7.9751L16.9955 10.8035ZM18.8138 8.98525L19.8047 7.99429C20.1953 7.60376 20.1953 6.9706 19.8047 6.58007L18.3905 5.16586C18 4.77534 17.3668 4.77534 16.9763 5.16586L15.9853 6.15683L18.8138 8.98525Z" fill="currentColor" />
                      <path d="M2 22.9502L4.12171 15.1717L9.77817 20.8289L2 22.9502Z" fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="-2" max="2" step="0.1" value="0.0" data-range="float" data-item="ai-openai-frequency" data-type="value" data-ai-openai-frequency="">
                  <div class="text">0.0</div>
                </div>
              </div>
            </div>
            <div class="row">
              <div class="text label" data-i18n-text="Limits"></div>
              <div class="column">
                <div class="row">
                  <div class="command" data-target="ai-openai-dialog" data-range-reset="4">
                    <svg viewBox="-100 -100 1224 1224" xmlns="http://www.w3.org/2000/svg">
                      <path d="M170.65984 42.65984l682.65984 0q53.00224 0 90.50112 37.49888t37.49888 90.50112l0 469.34016q0 53.00224-37.49888 90.50112t-90.50112 37.49888l-341.34016 0-298.65984 213.34016 0-213.34016-42.65984 0q-53.00224 0-90.50112-37.49888t-37.49888-90.50112l0-469.34016q0-53.00224 37.49888-90.50112t90.50112-37.49888zM853.34016 128l-682.65984 0q-17.67424 0-30.16704 12.4928t-12.4928 30.16704l0 469.34016q0 17.67424 12.4928 30.16704t30.16704 12.4928l128 0 0 132.99712 185.99936-132.99712 368.66048 0q17.67424 0 30.16704-12.4928t12.4928-30.16704l0-469.34016q0-17.67424-12.4928-30.16704t-30.16704-12.4928z" fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="2" max="10" step="2" value="4" data-range="dialog" data-item="ai-openai-dialog" data-type="value" data-ai-openai-dialog="">
                  <div class="text">4 sanomaa</div>
                </div>
                <div class="row">
                  <div class="command" data-target="ai-openai-input" data-range-reset="2000">
                    <svg viewBox="-1 -1 26 26" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path fill-rule="evenodd" clip-rule="evenodd" d="M9 4C9 2.34315 10.3431 1 12 1C13.6569 1 15 2.34315 15 4V12C15 13.6569 13.6569 15 12 15C10.3431 15 9 13.6569 9 12V4ZM13 4V12C13 12.5523 12.5523 13 12 13C11.4477 13 11 12.5523 11 12V4C11 3.44772 11.4477 3 12 3C12.5523 3 13 3.44772 13 4Z" fill="currentColor" />
                      <path d="M18 12C18 14.973 15.8377 17.441 13 17.917V21H17V23H7V21H11V17.917C8.16229 17.441 6 14.973 6 12V9H8V12C8 14.2091 9.79086 16 12 16C14.2091 16 16 14.2091 16 12V9H18V12Z" fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="100" max="4000" step="100" value="2000" data-range="word" data-item="ai-openai-input" data-type="value" data-ai-openai-input="">
                  <div class="text">1000 sanaa</div>
                </div>
                <div class="row">
                  <div class="command" data-target="ai-openai-output" data-range-reset="1000">
                    <svg viewBox="-2 -2 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path fill-rule="evenodd" clip-rule="evenodd" d="M12 18.939C14.2091 18.939 16 17.1482 16 14.939C16 12.7299 14.2091 10.939 12 10.939C9.79086 10.939 8 12.7299 8 14.939C8 17.1482 9.79086 18.939 12 18.939ZM12 16.939C13.1046 16.939 14 16.0436 14 14.939C14 13.8345 13.1046 12.939 12 12.939C10.8954 12.939 10 13.8345 10 14.939C10 16.0436 10.8954 16.939 12 16.939Z" fill="currentColor" />
                      <path d="M12 9.04401C13.1046 9.04401 14 8.14858 14 7.04401C14 5.93944 13.1046 5.04401 12 5.04401C10.8954 5.04401 10 5.93944 10 7.04401C10 8.14858 10.8954 9.04401 12 9.04401Z" fill="currentColor" />
                      <path fill-rule="evenodd" clip-rule="evenodd" d="M7 1C5.34315 1 4 2.34315 4 4V20C4 21.6569 5.34315 23 7 23H17C18.6569 23 20 21.6569 20 20V4C20 2.34315 18.6569 1 17 1H7ZM17 3H7C6.44772 3 6 3.44772 6 4V20C6 20.5523 6.44772 21 7 21H17C17.5523 21 18 20.5523 18 20V4C18 3.44772 17.5523 3 17 3Z" fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="100" max="4000" step="100" value="1000" data-range="word" data-item="ai-openai-output" data-type="value" data-ai-openai-output="">
                  <div class="text">2000 sanaa</div>
                </div>
              </div>
            </div>
            <div class="row">
              <div class="text label" data-i18n-text="ai-stop"></div>
              <input type="text" data-i18n-placeholder="ai-stopword" data-item="ai-openai-stop" data-type="value" data-ai-openai-stop="">
            </div>
            <div class="row">
              <div class="text label" data-i18n-text="ai-user"></div>
              <input type="text" data-i18n-placeholder="ai-username" data-item="ai-openai-user" data-type="value" data-ai-openai-user="">
            </div>
          </div>

          <div id="ai-grok" class="column">
            <div class="row">
              <div class="text label" data-i18n-text="System"></div>
              <textarea data-i18n-placeholder="ai-system" rows="1" autocapitalize="sentences" data-item="ai-openai-system" data-type="value" data-ai-openai-system=""></textarea>
            </div>
            <div class="row">
              <div class="text label" data-i18n-text="Example1"></div>
              <textarea data-i18n-placeholder="ai-user1" rows="1" autocapitalize="sentences" data-item="ai-openai-user1" data-type="value" data-ai-openai-user1=""></textarea>
            </div>
            <div class="row">
              <div class="text label"></div>
              <textarea data-i18n-placeholder="ai-ai1" rows="1" autocapitalize="sentences" data-item="ai-openai-ai1" data-type="value" data-ai-openai-ai1=""></textarea>
            </div>
            <div class="row">
              <div class="text label" data-i18n-text="Example2"></div>
              <textarea data-i18n-placeholder="ai-user2" rows="1" autocapitalize="sentences" data-item="ai-openai-user2" data-type="value" data-ai-openai-user2=""></textarea>
            </div>
            <div class="row">
              <div class="text label"></div>
              <textarea data-i18n-placeholder="ai-ai2" rows="1" autocapitalize="sentences" data-item="ai-openai-ai2" data-type="value" data-ai-openai-ai2=""></textarea>
            </div>
            
          <div class="row">
            <div class="text label" data-i18n-text="Limits"></div>
            <div class="column">
              <div class="row">
                <div class="command bonetester" style="width: 10px">x</div>
                <div id="limitsx1null" class="command limitsnull">
                  <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M10.5858 13.4142L7.75735 10.5858L6.34314 12L10.5858 16.2427L17.6568 9.1716L16.2426 7.75739L10.5858 13.4142Z" fill="currentColor" />
                  </svg>
                </div>
                <input id="limitsx1" class="limits" type="range" min="-0.5" max="0.5" step="0.01" value="0" data-range="meter" style="width: 358px">
                <div class="text">null</div>
              </div>
              <div class="row">
                <div class="text label" style="width: 10px"></div>
                <div id="limitsx2null" class="command limitsnull">
                  <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M10.5858 13.4142L7.75735 10.5858L6.34314 12L10.5858 16.2427L17.6568 9.1716L16.2426 7.75739L10.5858 13.4142Z" fill="currentColor" />
                  </svg>
                </div>
                <input id="limitsx2" class="limits" type="range" min="-0.5" max="0.5" step="0.01" value="0" data-range="meter" style="width: 358px">
                <div class="text">null</div>
              </div>
              <div class="row">
                <div class="command bonetester" style="width: 10px">y</div>
                <div id="limitsy1null" class="command limitsnull">
                  <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M10.5858 13.4142L7.75735 10.5858L6.34314 12L10.5858 16.2427L17.6568 9.1716L16.2426 7.75739L10.5858 13.4142Z" fill="currentColor" />
                  </svg>
                </div>
                <input  id="limitsy1" class="limits" type="range" min="-0.5" max="0.5" step="0.01" value="0" data-range="meter" style="width: 358px">
                <div class="text">null</div>
              </div>
              <div class="row">
                <div class="text label" style="width: 10px"></div>
                <div id="limitsy2null" class="command limitsnull">
                  <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M10.5858 13.4142L7.75735 10.5858L6.34314 12L10.5858 16.2427L17.6568 9.1716L16.2426 7.75739L10.5858 13.4142Z" fill="currentColor" />
                  </svg>
                </div>
                <input id="limitsy2" class="limits" type="range" min="-0.5" max="0.5" step="0.01" value="0" data-range="meter" style="width: 358px">
                <div class="text">null</div>
              </div>
              <div class="row">
                <div class="command bonetester" style="width: 10px">z</div>
                <div id="limitsz1null" class="command limitsnull">
                  <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M10.5858 13.4142L7.75735 10.5858L6.34314 12L10.5858 16.2427L17.6568 9.1716L16.2426 7.75739L10.5858 13.4142Z" fill="currentColor" />
                  </svg>
                </div>
                <input id="limitsz1" class="limits" type="range" min="-0.5" max="0.5" step="0.01" value="0" data-range="meter" style="width: 358px">
                <div class="text">null</div>
              </div>
              <div class="row">
                <div class="text label" style="width: 10px"></div>
                <div id="limitsz2null" class="command limitsnull">
                  <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M10.5858 13.4142L7.75735 10.5858L6.34314 12L10.5858 16.2427L17.6568 9.1716L16.2426 7.75739L10.5858 13.4142Z" fill="currentColor" />
                  </svg>
                </div>
                <input id="limitsz2" class="limits" type="range" min="-0.5" max="0.5" step="0.01" value="0" data-range="meter" style="width: 358px">
                <div class="text">null</div>
              </div>
              <div class="row">
                <div class="command bonetester" style="width: 10px">t</div>
                <div id="limitst1null" class="command limitsnull">
                  <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M10.5858 13.4142L7.75735 10.5858L6.34314 12L10.5858 16.2427L17.6568 9.1716L16.2426 7.75739L10.5858 13.4142Z" fill="currentColor" />
                  </svg>
                </div>
                <input  id="limitst1" class="limits" type="range" min="-0.5" max="0.5" step="0.01" value="0" data-range="meter" style="width: 358px">
                <div class="text">null</div>
              </div>
              <div class="row">
                <div class="text label" style="width: 10px"></div>
                <div id="limitst2null" class="command limitsnull">
                  <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M10.5858 13.4142L7.75735 10.5858L6.34314 12L10.5858 16.2427L17.6568 9.1716L16.2426 7.75739L10.5858 13.4142Z" fill="currentColor" />
                  </svg>
                </div>
                <input  id="limitst2" class="limits" type="range" min="-0.5" max="0.5" step="0.01" value="0" data-range="meter" style="width: 358px">
                <div class="text">null</div>
              </div>
            </div>
          </div>


            <div class="vbar"></div>

            <div class="row">
              <div class="text label" data-i18n-text="Adjust"></div>
              <div class="column">
                <div class="row">
                  <div class="command" data-target="ai-grok-temperature" data-range-reset="1.0">
                    <svg viewBox="0 0 1024 1024" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M336 972.8c-60.8-128-28.8-201.6 19.2-268.8 51.2-76.8 64-150.4 64-150.4s41.6 51.2 25.6 134.4c70.4-80 83.2-208 73.6-256 160 112 230.4 358.4 137.6 537.6 492.8-281.6 121.6-700.8 57.6-745.6 22.4 48 25.6 128-19.2 166.4-73.6-281.6-256-336-256-336 22.4 144-76.8 300.8-172.8 419.2-3.2-57.6-6.4-96-38.4-153.6-6.4 105.6-86.4 188.8-108.8 294.4C89.6 758.4 140.8 860.8 336 972.8L336 972.8z"  fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="0" max="2" step="0.1" value="1.0" data-range="float" data-item="ai-grok-temperature" data-type="value" data-ai-grok-temperature="">
                  <div class="text">1.0</div>
                </div>
                <div class="row">
                  <div class="command" data-target="ai-grok-presence" data-range-reset="0.0">
                    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M9.00967 5.12761H11.0097C12.1142 5.12761 13.468 5.89682 14.0335 6.8457L16.5089 11H21.0097C21.562 11 22.0097 11.4477 22.0097 12C22.0097 12.5523 21.562 13 21.0097 13H16.4138L13.9383 17.1543C13.3729 18.1032 12.0191 18.8724 10.9145 18.8724H8.91454L12.4138 13H5.42485L3.99036 15.4529H1.99036L4.00967 12L4.00967 11.967L2.00967 8.54712H4.00967L5.44417 11H12.5089L9.00967 5.12761Z" fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="-1" max="2" step="0.1" value="0.0" data-range="float" data-item="ai-grok-presence" data-type="value" data-ai-grok-presence="">
                  <div class="text">0.0</div>
                </div>
                <div class="row">
                  <div class="command" data-target="ai-grok-frequency" data-range-reset="0.0">
                    <svg viewBox="-2 -2 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path fill-rule="evenodd" clip-rule="evenodd" d="M21.2635 2.29289C20.873 1.90237 20.2398 1.90237 19.8493 2.29289L18.9769 3.16525C17.8618 2.63254 16.4857 2.82801 15.5621 3.75165L4.95549 14.3582L10.6123 20.0151L21.2189 9.4085C22.1426 8.48486 22.338 7.1088 21.8053 5.99367L22.6777 5.12132C23.0682 4.7308 23.0682 4.09763 22.6777 3.70711L21.2635 2.29289ZM16.9955 10.8035L10.6123 17.1867L7.78392 14.3582L14.1671 7.9751L16.9955 10.8035ZM18.8138 8.98525L19.8047 7.99429C20.1953 7.60376 20.1953 6.9706 19.8047 6.58007L18.3905 5.16586C18 4.77534 17.3668 4.77534 16.9763 5.16586L15.9853 6.15683L18.8138 8.98525Z" fill="currentColor" />
                      <path d="M2 22.9502L4.12171 15.1717L9.77817 20.8289L2 22.9502Z" fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="-2" max="2" step="0.1" value="0.0" data-range="float" data-item="ai-grok-frequency" data-type="value" data-ai-grok-frequency="">
                  <div class="text">0.0</div>
                </div>
              </div>
            </div>
            <div class="row">
              <div class="text label" data-i18n-text="Limits"></div>
              <div class="column">
                <div class="row">
                  <div class="command" data-target="ai-grok-dialog" data-range-reset="4">
                    <svg viewBox="-100 -100 1224 1224" xmlns="http://www.w3.org/2000/svg">
                      <path d="M170.65984 42.65984l682.65984 0q53.00224 0 90.50112 37.49888t37.49888 90.50112l0 469.34016q0 53.00224-37.49888 90.50112t-90.50112 37.49888l-341.34016 0-298.65984 213.34016 0-213.34016-42.65984 0q-53.00224 0-90.50112-37.49888t-37.49888-90.50112l0-469.34016q0-53.00224 37.49888-90.50112t90.50112-37.49888zM853.34016 128l-682.65984 0q-17.67424 0-30.16704 12.4928t-12.4928 30.16704l0 469.34016q0 17.67424 12.4928 30.16704t30.16704 12.4928l128 0 0 132.99712 185.99936-132.99712 368.66048 0q17.67424 0 30.16704-12.4928t12.4928-30.16704l0-469.34016q0-17.67424-12.4928-30.16704t-30.16704-12.4928z" fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="2" max="10" step="2" value="4" data-range="dialog" data-item="ai-grok-dialog" data-type="value" data-ai-grok-dialog="">
                  <div class="text">4 sanomaa</div>
                </div>
                <div class="row">
                  <div class="command" data-target="ai-grok-input" data-range-reset="2000">
                    <svg viewBox="-1 -1 26 26" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path fill-rule="evenodd" clip-rule="evenodd" d="M9 4C9 2.34315 10.3431 1 12 1C13.6569 1 15 2.34315 15 4V12C15 13.6569 13.6569 15 12 15C10.3431 15 9 13.6569 9 12V4ZM13 4V12C13 12.5523 12.5523 13 12 13C11.4477 13 11 12.5523 11 12V4C11 3.44772 11.4477 3 12 3C12.5523 3 13 3.44772 13 4Z" fill="currentColor" />
                      <path d="M18 12C18 14.973 15.8377 17.441 13 17.917V21H17V23H7V21H11V17.917C8.16229 17.441 6 14.973 6 12V9H8V12C8 14.2091 9.79086 16 12 16C14.2091 16 16 14.2091 16 12V9H18V12Z" fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="100" max="4000" step="100" value="2000" data-range="word" data-item="ai-grok-input" data-type="value" data-ai-grok-input="">
                  <div class="text">1000 sanaa</div>
                </div>
                <div class="row">
                  <div class="command" data-target="ai-grok-output" data-range-reset="1000">
                    <svg viewBox="-2 -2 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path fill-rule="evenodd" clip-rule="evenodd" d="M12 18.939C14.2091 18.939 16 17.1482 16 14.939C16 12.7299 14.2091 10.939 12 10.939C9.79086 10.939 8 12.7299 8 14.939C8 17.1482 9.79086 18.939 12 18.939ZM12 16.939C13.1046 16.939 14 16.0436 14 14.939C14 13.8345 13.1046 12.939 12 12.939C10.8954 12.939 10 13.8345 10 14.939C10 16.0436 10.8954 16.939 12 16.939Z" fill="currentColor" />
                      <path d="M12 9.04401C13.1046 9.04401 14 8.14858 14 7.04401C14 5.93944 13.1046 5.04401 12 5.04401C10.8954 5.04401 10 5.93944 10 7.04401C10 8.14858 10.8954 9.04401 12 9.04401Z" fill="currentColor" />
                      <path fill-rule="evenodd" clip-rule="evenodd" d="M7 1C5.34315 1 4 2.34315 4 4V20C4 21.6569 5.34315 23 7 23H17C18.6569 23 20 21.6569 20 20V4C20 2.34315 18.6569 1 17 1H7ZM17 3H7C6.44772 3 6 3.44772 6 4V20C6 20.5523 6.44772 21 7 21H17C17.5523 21 18 20.5523 18 20V4C18 3.44772 17.5523 3 17 3Z" fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="100" max="4000" step="100" value="1000" data-range="word" data-item="ai-grok-output" data-type="value" data-ai-grok-output="">
                  <div class="text">2000 sanaa</div>
                </div>
              </div>
            </div>
            <div class="row">
              <div class="text label" data-i18n-text="ai-stop"></div>
              <input type="text" data-i18n-placeholder="ai-stopword" data-item="ai-grok-stop" data-type="value" data-ai-grok-stop="">
            </div>
            <div class="row">
              <div class="text label" data-i18n-text="ai-user"></div>
              <input type="text" data-i18n-placeholder="ai-username" data-item="ai-grok-user" data-type="value" data-ai-grok-user="">
            </div>
          </div>

          <div id="ai-llama" class="column">
            <div class="row">
              <div class="text label" data-i18n-text="System"></div>
              <textarea data-i18n-placeholder="ai-system" rows="1" autocapitalize="sentences" data-item="ai-openai-system" data-type="value" data-ai-openai-system=""></textarea>
            </div>
            <div class="row">
              <div class="text label" data-i18n-text="Example1"></div>
              <textarea data-i18n-placeholder="ai-user1" rows="1" autocapitalize="sentences" data-item="ai-openai-user1" data-type="value" data-ai-openai-user1=""></textarea>
            </div>
            <div class="row">
              <div class="text label"></div>
              <textarea data-i18n-placeholder="ai-ai1" rows="1" autocapitalize="sentences" data-item="ai-openai-ai1" data-type="value" data-ai-openai-ai1=""></textarea>
            </div>
            <div class="row">
              <div class="text label" data-i18n-text="Example2"></div>
              <textarea data-i18n-placeholder="ai-user2" rows="1" autocapitalize="sentences" data-item="ai-openai-user2" data-type="value" data-ai-openai-user2=""></textarea>
            </div>
            <div class="row">
              <div class="text label"></div>
              <textarea data-i18n-placeholder="ai-ai2" rows="1" autocapitalize="sentences" data-item="ai-openai-ai2" data-type="value" data-ai-openai-ai2=""></textarea>
            </div>

            <div class="vbar"></div>

            <div class="row">
              <div class="text label" data-i18n-text="Adjust"></div>
              <div class="column">
                <div class="row">
                  <div class="command" data-target="ai-llama-temperature" data-range-reset="1.0">
                    <svg viewBox="0 0 1024 1024" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M336 972.8c-60.8-128-28.8-201.6 19.2-268.8 51.2-76.8 64-150.4 64-150.4s41.6 51.2 25.6 134.4c70.4-80 83.2-208 73.6-256 160 112 230.4 358.4 137.6 537.6 492.8-281.6 121.6-700.8 57.6-745.6 22.4 48 25.6 128-19.2 166.4-73.6-281.6-256-336-256-336 22.4 144-76.8 300.8-172.8 419.2-3.2-57.6-6.4-96-38.4-153.6-6.4 105.6-86.4 188.8-108.8 294.4C89.6 758.4 140.8 860.8 336 972.8L336 972.8z"  fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="0" max="2" step="0.1" value="1.0" data-range="float" data-item="ai-llama-temperature" data-type="value" data-ai-llama-temperature="">
                  <div class="text">1.0</div>
                </div>
                <div class="row">
                  <div class="command" data-target="ai-llama-presence" data-range-reset="0.0">
                    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M9.00967 5.12761H11.0097C12.1142 5.12761 13.468 5.89682 14.0335 6.8457L16.5089 11H21.0097C21.562 11 22.0097 11.4477 22.0097 12C22.0097 12.5523 21.562 13 21.0097 13H16.4138L13.9383 17.1543C13.3729 18.1032 12.0191 18.8724 10.9145 18.8724H8.91454L12.4138 13H5.42485L3.99036 15.4529H1.99036L4.00967 12L4.00967 11.967L2.00967 8.54712H4.00967L5.44417 11H12.5089L9.00967 5.12761Z" fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="-1" max="2" step="0.1" value="0.0" data-range="float" data-item="ai-llama-presence" data-type="value" data-ai-llama-presence="">
                  <div class="text">0.0</div>
                </div>
                <div class="row">
                  <div class="command" data-target="ai-llama-frequency" data-range-reset="0.0">
                    <svg viewBox="-2 -2 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path fill-rule="evenodd" clip-rule="evenodd" d="M21.2635 2.29289C20.873 1.90237 20.2398 1.90237 19.8493 2.29289L18.9769 3.16525C17.8618 2.63254 16.4857 2.82801 15.5621 3.75165L4.95549 14.3582L10.6123 20.0151L21.2189 9.4085C22.1426 8.48486 22.338 7.1088 21.8053 5.99367L22.6777 5.12132C23.0682 4.7308 23.0682 4.09763 22.6777 3.70711L21.2635 2.29289ZM16.9955 10.8035L10.6123 17.1867L7.78392 14.3582L14.1671 7.9751L16.9955 10.8035ZM18.8138 8.98525L19.8047 7.99429C20.1953 7.60376 20.1953 6.9706 19.8047 6.58007L18.3905 5.16586C18 4.77534 17.3668 4.77534 16.9763 5.16586L15.9853 6.15683L18.8138 8.98525Z" fill="currentColor" />
                      <path d="M2 22.9502L4.12171 15.1717L9.77817 20.8289L2 22.9502Z" fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="-2" max="2" step="0.1" value="0.0" data-range="float" data-item="ai-llama-frequency" data-type="value" data-ai-llama-frequency="">
                  <div class="text">0.0</div>
                </div>
              </div>
            </div>
            <div class="row">
              <div class="text label" data-i18n-text="Limits"></div>
              <div class="column">
                <div class="row">
                  <div class="command" data-target="ai-llama-dialog" data-range-reset="4">
                    <svg viewBox="-100 -100 1224 1224" xmlns="http://www.w3.org/2000/svg">
                      <path d="M170.65984 42.65984l682.65984 0q53.00224 0 90.50112 37.49888t37.49888 90.50112l0 469.34016q0 53.00224-37.49888 90.50112t-90.50112 37.49888l-341.34016 0-298.65984 213.34016 0-213.34016-42.65984 0q-53.00224 0-90.50112-37.49888t-37.49888-90.50112l0-469.34016q0-53.00224 37.49888-90.50112t90.50112-37.49888zM853.34016 128l-682.65984 0q-17.67424 0-30.16704 12.4928t-12.4928 30.16704l0 469.34016q0 17.67424 12.4928 30.16704t30.16704 12.4928l128 0 0 132.99712 185.99936-132.99712 368.66048 0q17.67424 0 30.16704-12.4928t12.4928-30.16704l0-469.34016q0-17.67424-12.4928-30.16704t-30.16704-12.4928z" fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="2" max="10" step="2" value="4" data-range="dialog" data-item="ai-llama-dialog" data-type="value" data-ai-llama-dialog="">
                  <div class="text">4 sanomaa</div>
                </div>
                <div class="row">
                  <div class="command" data-target="ai-llama-input" data-range-reset="2000">
                    <svg viewBox="-1 -1 26 26" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path fill-rule="evenodd" clip-rule="evenodd" d="M9 4C9 2.34315 10.3431 1 12 1C13.6569 1 15 2.34315 15 4V12C15 13.6569 13.6569 15 12 15C10.3431 15 9 13.6569 9 12V4ZM13 4V12C13 12.5523 12.5523 13 12 13C11.4477 13 11 12.5523 11 12V4C11 3.44772 11.4477 3 12 3C12.5523 3 13 3.44772 13 4Z" fill="currentColor" />
                      <path d="M18 12C18 14.973 15.8377 17.441 13 17.917V21H17V23H7V21H11V17.917C8.16229 17.441 6 14.973 6 12V9H8V12C8 14.2091 9.79086 16 12 16C14.2091 16 16 14.2091 16 12V9H18V12Z" fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="100" max="4000" step="100" value="2000" data-range="word" data-item="ai-llama-input" data-type="value" data-ai-llama-input="">
                  <div class="text">1000 sanaa</div>
                </div>
                <div class="row">
                  <div class="command" data-target="ai-llama-output" data-range-reset="1000">
                    <svg viewBox="-2 -2 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path fill-rule="evenodd" clip-rule="evenodd" d="M12 18.939C14.2091 18.939 16 17.1482 16 14.939C16 12.7299 14.2091 10.939 12 10.939C9.79086 10.939 8 12.7299 8 14.939C8 17.1482 9.79086 18.939 12 18.939ZM12 16.939C13.1046 16.939 14 16.0436 14 14.939C14 13.8345 13.1046 12.939 12 12.939C10.8954 12.939 10 13.8345 10 14.939C10 16.0436 10.8954 16.939 12 16.939Z" fill="currentColor" />
                      <path d="M12 9.04401C13.1046 9.04401 14 8.14858 14 7.04401C14 5.93944 13.1046 5.04401 12 5.04401C10.8954 5.04401 10 5.93944 10 7.04401C10 8.14858 10.8954 9.04401 12 9.04401Z" fill="currentColor" />
                      <path fill-rule="evenodd" clip-rule="evenodd" d="M7 1C5.34315 1 4 2.34315 4 4V20C4 21.6569 5.34315 23 7 23H17C18.6569 23 20 21.6569 20 20V4C20 2.34315 18.6569 1 17 1H7ZM17 3H7C6.44772 3 6 3.44772 6 4V20C6 20.5523 6.44772 21 7 21H17C17.5523 21 18 20.5523 18 20V4C18 3.44772 17.5523 3 17 3Z" fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="100" max="4000" step="100" value="1000" data-range="word" data-item="ai-llama-output" data-type="value" data-ai-llama-output="">
                  <div class="text">2000 sanaa</div>
                </div>
              </div>
            </div>
            <div class="row">
              <div class="text label" data-i18n-text="ai-stop"></div>
              <input type="text" data-i18n-placeholder="ai-stopword" data-item="ai-llama-stop" data-type="value" data-ai-llama-stop="">
            </div>
            <div class="row">
              <div class="text label" data-i18n-text="ai-user"></div>
              <input type="text" data-i18n-placeholder="ai-username" data-item="ai-llama-user" data-type="value" data-ai-llama-user="">
            </div>
          </div>

          <div id="ai-gemini" class="column">
            <div class="row">
              <div class="text label" data-i18n-text="System"></div>
              <textarea data-i18n-placeholder="ai-system" rows="1" autocapitalize="sentences" data-item="ai-gemini-system" data-type="value" data-ai-gemini-system=""></textarea>
            </div>
            <div class="row">
              <div class="text label" data-i18n-text="Example1"></div>
              <textarea data-i18n-placeholder="ai-user1" rows="1" autocapitalize="sentences" data-item="ai-gemini-user1" data-type="value" data-ai-gemini-user1=""></textarea>
            </div>
            <div class="row">
              <div class="text label"></div>
              <textarea data-i18n-placeholder="ai-ai1" rows="1" autocapitalize="sentences" data-item="ai-gemini-ai1" data-type="value" data-ai-gemini-ai1=""></textarea>
            </div>
            <div class="row">
              <div class="text label" data-i18n-text="Example2"></div>
              <textarea data-i18n-placeholder="ai-user2" rows="1" autocapitalize="sentences" data-item="ai-gemini-user2" data-type="value" data-ai-gemini-user2=""></textarea>
            </div>
            <div class="row">
              <div class="text label"></div>
              <textarea data-i18n-placeholder="ai-ai2" rows="1" autocapitalize="sentences" data-item="ai-gemini-ai2" data-type="value" data-ai-gemini-ai2=""></textarea>
            </div>

            <div class="vbar"></div>

            <div class="row">
              <div class="text label" data-i18n-text="Adjust"></div>
              <div class="column">
                <div class="row">
                  <div class="command" data-target="ai-gemini-temperature" data-range-reset="1.0">
                    <svg viewBox="0 0 1024 1024" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M336 972.8c-60.8-128-28.8-201.6 19.2-268.8 51.2-76.8 64-150.4 64-150.4s41.6 51.2 25.6 134.4c70.4-80 83.2-208 73.6-256 160 112 230.4 358.4 137.6 537.6 492.8-281.6 121.6-700.8 57.6-745.6 22.4 48 25.6 128-19.2 166.4-73.6-281.6-256-336-256-336 22.4 144-76.8 300.8-172.8 419.2-3.2-57.6-6.4-96-38.4-153.6-6.4 105.6-86.4 188.8-108.8 294.4C89.6 758.4 140.8 860.8 336 972.8L336 972.8z"  fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="0" max="1" step="0.1" value="1.0" data-range="float" data-item="ai-gemini-temperature" data-type="value" data-ai-gemini-temperature="">
                  <div class="text">1.0</div>
                </div>
                <div class="row">
                  <div class="command" data-target="ai-gemini-topp" data-range-reset="1.0" style="display:block; text-align: center; width: 2rem;">P</div>
                  <input type="range" min="0" max="1" step="0.05" value="1.0" data-range="float" data-item="ai-gemini-topp" data-type="value" data-ai-gemini-topp="">
                  <div class="text">1.0</div>
                </div>
                <div class="row">
                  <div class="command" data-target="ai-gemini-topk" data-range-reset="40" style="display:block; text-align: center; width: 2rem;">K</div>
                  <input type="range" min="1" max="40" step="1" value="40" data-range="float" data-item="ai-gemini-topk" data-type="value" data-ai-gemini-topk="">
                  <div class="text">40</div>
                </div>
              </div>
            </div>
            <div class="row">
              <div class="text label" data-i18n-text="Limits"></div>
              <div class="column">
                <div class="row">
                  <div class="command" data-target="ai-gemini-dialog" data-range-reset="4">
                    <svg viewBox="-100 -100 1224 1224" xmlns="http://www.w3.org/2000/svg">
                      <path d="M170.65984 42.65984l682.65984 0q53.00224 0 90.50112 37.49888t37.49888 90.50112l0 469.34016q0 53.00224-37.49888 90.50112t-90.50112 37.49888l-341.34016 0-298.65984 213.34016 0-213.34016-42.65984 0q-53.00224 0-90.50112-37.49888t-37.49888-90.50112l0-469.34016q0-53.00224 37.49888-90.50112t90.50112-37.49888zM853.34016 128l-682.65984 0q-17.67424 0-30.16704 12.4928t-12.4928 30.16704l0 469.34016q0 17.67424 12.4928 30.16704t30.16704 12.4928l128 0 0 132.99712 185.99936-132.99712 368.66048 0q17.67424 0 30.16704-12.4928t12.4928-30.16704l0-469.34016q0-17.67424-12.4928-30.16704t-30.16704-12.4928z" fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="2" max="10" step="2" value="4" data-range="dialog" data-item="ai-gemini-dialog" data-type="value" data-ai-gemini-dialog="">
                  <div class="text">4 sanomaa</div>
                </div>
                <div class="row">
                  <div class="command" data-target="ai-gemini-input" data-range-reset="2000">
                    <svg viewBox="-1 -1 26 26" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path fill-rule="evenodd" clip-rule="evenodd" d="M9 4C9 2.34315 10.3431 1 12 1C13.6569 1 15 2.34315 15 4V12C15 13.6569 13.6569 15 12 15C10.3431 15 9 13.6569 9 12V4ZM13 4V12C13 12.5523 12.5523 13 12 13C11.4477 13 11 12.5523 11 12V4C11 3.44772 11.4477 3 12 3C12.5523 3 13 3.44772 13 4Z" fill="currentColor" />
                      <path d="M18 12C18 14.973 15.8377 17.441 13 17.917V21H17V23H7V21H11V17.917C8.16229 17.441 6 14.973 6 12V9H8V12C8 14.2091 9.79086 16 12 16C14.2091 16 16 14.2091 16 12V9H18V12Z" fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="100" max="4000" step="100" value="2000" data-range="word" data-item="ai-gemini-input" data-type="value" data-ai-gemini-input="">
                  <div class="text">1000 sanaa</div>
                </div>
                <div class="row">
                  <div class="command" data-target="ai-gemini-output" data-range-reset="1000">
                    <svg viewBox="-2 -2 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path fill-rule="evenodd" clip-rule="evenodd" d="M12 18.939C14.2091 18.939 16 17.1482 16 14.939C16 12.7299 14.2091 10.939 12 10.939C9.79086 10.939 8 12.7299 8 14.939C8 17.1482 9.79086 18.939 12 18.939ZM12 16.939C13.1046 16.939 14 16.0436 14 14.939C14 13.8345 13.1046 12.939 12 12.939C10.8954 12.939 10 13.8345 10 14.939C10 16.0436 10.8954 16.939 12 16.939Z" fill="currentColor" />
                      <path d="M12 9.04401C13.1046 9.04401 14 8.14858 14 7.04401C14 5.93944 13.1046 5.04401 12 5.04401C10.8954 5.04401 10 5.93944 10 7.04401C10 8.14858 10.8954 9.04401 12 9.04401Z" fill="currentColor" />
                      <path fill-rule="evenodd" clip-rule="evenodd" d="M7 1C5.34315 1 4 2.34315 4 4V20C4 21.6569 5.34315 23 7 23H17C18.6569 23 20 21.6569 20 20V4C20 2.34315 18.6569 1 17 1H7ZM17 3H7C6.44772 3 6 3.44772 6 4V20C6 20.5523 6.44772 21 7 21H17C17.5523 21 18 20.5523 18 20V4C18 3.44772 17.5523 3 17 3Z" fill="currentColor" />
                    </svg>
                  </div>
                  <input type="range" min="100" max="4000" step="100" value="1000" data-range="word" data-item="ai-gemini-output" data-type="value" data-ai-gemini-output="">
                  <div class="text">2000 sanaa</div>
                </div>
              </div>
            </div>
            <div class="row">
              <div class="text label" data-i18n-text="ai-stop"></div>
              <input type="text" data-i18n-placeholder="ai-stopword" data-item="ai-gemini-stop" data-type="value" data-ai-gemini-stop="">
            </div>
          </div>

          <div class="vbar"></div>

          <div class="row">
            <div class="text label" data-i18n-text="Script"></div>
            <textarea id="script" data-i18n-placeholder="Script" data-item="script-text" data-type="value" data-script-text=""></textarea>
          </div>

        </div>


        <div id="right-sessions" class="page">
          <div id="sessions">
            <div id="session-0" class="session selected"></div>
            <div id="session-1" class="session"></div>
          </div>
        </div>
<div id="right-session" class="page noselect nodrag">

          <div class="vbar"></div>

          <div class="row">
            <div class="text label" data-i18n-text="Session">Session</div>
            <div id="directory" class="column fill">
              <div id="entry-0" class="entry row">
                <div class="command fill selected" data-session="0">Nimetön</div>
                <div class="command" data-entry-move="up">
                  <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M17.6569 16.2427L19.0711 14.8285L12.0001 7.75739L4.92896 14.8285L6.34317 16.2427L12.0001 10.5858L17.6569 16.2427Z" fill="currentColor"></path>
                  </svg>
                </div>
                <div class="command" data-entry-move="down">
                  <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M6.34317 7.75732L4.92896 9.17154L12 16.2426L19.0711 9.17157L17.6569 7.75735L12 13.4142L6.34317 7.75732Z" fill="currentColor"></path>
                  </svg>
                </div>
              </div>
            </div>
          </div>

          

          

          

          

          <div class="vbar"></div>

          

          <div class="row">
            <div class="text label" style="width: 8rem">OpenAI</div>
            <input id="apikey-openai" class="apikey" type="text" placeholder="API key not specified; using proxy/JWT">
          </div>

          

          

          <div class="row">
            <div class="text label" style="width: 8rem">GoogleTTS</div>
            <input id="apikey-gtts" class="apikey" type="text" placeholder="API key not specified; using proxy/JWT">
          </div>

          

          

        </div>
      </div>

      <div class="border starttransparent"></div>
    </div>


    <div id="bottom">
      <div class="pages noselect nodrag">

        <div class="page fill">
          <div class="row fill">
            <textarea id="input" class="starttransparent"  data-i18n-placeholder="input" autocapitalize="sentences"></textarea>
          </div>
        </div>

        <div class="row" style="column-gap:0;">
          <div id="selectall" class="command starttransparent">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10.5858 13.4142L7.75735 10.5858L6.34314 12L10.5858 16.2427L17.6568 9.1716L16.2426 7.75739L10.5858 13.4142Z" fill="currentColor" />
            </svg>
          </div>
          <div id="flag" class="command starttransparent">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path fill-rule="evenodd" clip-rule="evenodd" d="M7 8V13C7 15.7614 9.23858 18 12 18C14.7614 18 17 15.7614 17 13V8H7ZM5 4H19V13C19 16.866 15.866 20 12 20C8.13401 20 5 16.866 5 13V4Z" fill="currentColor" />
            </svg>
          </div>
          <div id="score" class="text starttransparent" style="margin-left:-8px;">0</div>
          <div id="scripttag" class="command starttransparent">
            <svg viewBox="-4 -4 32 32" xmlns="http://www.w3.org/2000/svg">
              <path d="M17 9H7V7H17V9Z" fill="currentColor" /><path d="M7 13H17V11H7V13Z" fill="currentColor" /><path fill-rule="evenodd" clip-rule="evenodd" d="M2 18V2H22V18H16V22H14C11.7909 22 10 20.2091 10 18H2ZM12 16V18C12 19.1046 12.8954 20 14 20V16H20V4H4V16H12Z" fill="currentColor" />
            </svg>
          </div>
          <div id="scriptstatus" class="text starttransparent" style="margin-left:-8px;">1/1</div>
          <div class="filler"></div>
          <div id="record" class="command starttransparent" data-i18n-title="Record">
            <svg viewBox="-2 -2 28 28" xmlns="http://www.w3.org/2000/svg">
              <path fill-rule="evenodd" clip-rule="evenodd" d="M9 4C9 2.34315 10.3431 1 12 1C13.6569 1 15 2.34315 15 4V12C15 13.6569 13.6569 15 12 15C10.3431 15 9 13.6569 9 12V4ZM13 4V12C13 12.5523 12.5523 13 12 13C11.4477 13 11 12.5523 11 12V4C11 3.44772 11.4477 3 12 3C12.5523 3 13 3.44772 13 4Z" fill="currentColor" />
              <path d="M18 12C18 14.973 15.8377 17.441 13 17.917V21H17V23H7V21H11V17.917C8.16229 17.441 6 14.973 6 12V9H8V12C8 14.2091 9.79086 16 12 16C14.2091 16 16 14.2091 16 12V9H18V12Z" fill="currentColor" />
            </svg>
          </div>
          <div id="motion" class="command starttransparent" data-i18n-title="Motion">
            <svg viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">
              <path d="M 34.498047 3 C 32.014047 3 30 5.0150469 30 7.4980469 C 30 9.9830469 32.014047 12 34.498047 12 C 36.987047 12 39 9.9830469 39 7.4980469 C 39 5.0150469 36.987047 3 34.498047 3 z M 20 10 A 2 2 0 0 0 18.919922 10.316406 L 18.917969 10.316406 L 18.886719 10.322266 L 11.957031 15.294922 A 2 2 0 0 0 11 17 A 2 2 0 0 0 13 19 A 2 2 0 0 0 14.287109 18.527344 L 14.289062 18.529297 L 20.283203 14.21875 L 24.691406 15.619141 L 19.757812 23.660156 L 19.757812 23.664062 A 4 4 0 0 0 19 26 A 4 4 0 0 0 21.210938 29.572266 L 28.755859 34.226562 L 27.048828 43.009766 A 2.5 2.5 0 0 0 27 43.5 A 2.5 2.5 0 0 0 29.5 46 A 2.5 2.5 0 0 0 31.955078 43.962891 L 31.957031 43.962891 L 33.984375 33.289062 L 33.978516 33.273438 A 2 2 0 0 0 34 33 A 2 2 0 0 0 33.345703 31.523438 L 33.339844 31.507812 L 27.9375 26.720703 L 32.607422 17.486328 L 32.605469 17.482422 A 3 3 0 0 0 33 16 A 3 3 0 0 0 31.193359 13.248047 L 31.191406 13.244141 L 28.685547 11.849609 L 20.519531 10.066406 L 20.507812 10.068359 A 2 2 0 0 0 20 10 z M 34.212891 18.742188 L 31.972656 23.171875 L 33.181641 25.837891 L 33.193359 25.845703 C 33.513359 26.525703 34.199 27 35 27 L 42 27 C 43.105 27 44 26.105 44 25 C 44 23.895 43.105 23 42 23 L 36 23 L 34.212891 18.742188 z M 17.517578 28.414062 L 15.242188 32 L 7.5 32 C 6.119 32 5 33.119 5 34.5 C 5 35.881 6.119 37 7.5 37 L 15.931641 37 C 17.228641 37 18.445312 36.3705 19.195312 35.3125 L 21.480469 32.089844 C 20.653469 31.578844 20.055828 31.208125 20.048828 31.203125 C 18.904828 30.555125 18.031578 29.569062 17.517578 28.414062 z"  fill="currentColor"/>
            </svg>
          </div>
          <div id="copy" class="command starttransparent">
            <svg viewBox="-2 -2 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M13 7H7V5H13V7Z" fill="currentColor" />
              <path d="M13 11H7V9H13V11Z" fill="currentColor" />
              <path d="M7 15H13V13H7V15Z" fill="currentColor" />
              <path fill-rule="evenodd" clip-rule="evenodd" d="M3 19V1H17V5H21V23H7V19H3ZM15 17V3H5V17H15ZM17 7V19H9V21H19V7H17Z" fill="currentColor" />
            </svg>
          </div>
          <div id="delete" class="command starttransparent">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path fill-rule="evenodd" clip-rule="evenodd" d="M17 5V4C17 2.89543 16.1046 2 15 2H9C7.89543 2 7 2.89543 7 4V5H4C3.44772 5 3 5.44772 3 6C3 6.55228 3.44772 7 4 7H5V18C5 19.6569 6.34315 21 8 21H16C17.6569 21 19 19.6569 19 18V7H20C20.5523 7 21 6.55228 21 6C21 5.44772 20.5523 5 20 5H17ZM15 4H9V5H15V4ZM17 7H7V18C7 18.5523 7.44772 19 8 19H16C16.5523 19 17 18.5523 17 18V7Z" fill="currentColor" />
              <path d="M9 9H11V17H9V9Z" fill="currentColor" />
              <path d="M13 9H15V17H13V9Z" fill="currentColor" />
            </svg>
          </div>
        </div>
      </div>

      <div class="border starttransparent"></div>
    </div>

  </div>

  <script>
    window.addEventListener("click", () => {
  if (typeof AudioContext !== "undefined") {
    const context = new AudioContext();
    if (context.state === "suspended") {
      context.resume().then(() => {
        console.log("🔊 AudioContext activado por clic del usuario.");
      });
    }
  }
}, { once: true });
  </script>

</body>
</html>
